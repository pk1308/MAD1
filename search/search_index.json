{"config":{"indexing":"full","lang":["en"],"min_search_length":3,"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"Comprehensive HTML cheat sheet # HTML Cheat Sheet ## Basic Structure ```html <!DOCTYPE html> <html> <head> <title>Page Title</title> </head> <body> <!-- Content goes here --> </body> </html> Document Metadata <!DOCTYPE html> <!-- Document type declaration --> < html lang = \"en\" > <!-- Sets the language of the document --> < head > < meta charset = \"UTF-8\" > <!-- Character encoding --> < meta name = \"viewport\" content = \"width=device-width, initial-scale=1.0\" > <!-- Responsive design --> < title > Document </ title > <!-- Document title --> </ head > < body > <!-- Body content --> </ body > </ html > Headings < h1 > This is a Heading 1 </ h1 > < h2 > This is a Heading 2 </ h2 > < h3 > This is a Heading 3 </ h3 > < h4 > This is a Heading 4 </ h4 > < h5 > This is a Heading 5 </ h5 > < h6 > This is a Heading 6 </ h6 > Paragraphs and Line Breaks < p > This is a paragraph. </ p > < p > This is another paragraph. </ p > < p > This is a paragraph with a < br > line break. </ p > Text Formatting < b > Bold </ b > or < strong > Strong </ strong > <!-- Bold text --> < i > Italic </ i > or < em > Emphasized </ em > <!-- Italic text --> < u > Underline </ u > <!-- Underlined text --> < del > Deleted </ del > <!-- Strikethrough text --> < mark > Highlighted </ mark > <!-- Highlighted text --> < sup > Superscript </ sup > <!-- Superscript text --> < sub > Subscript </ sub > <!-- Subscript text --> Links < a href = \"https://www.example.com\" > This is a link </ a > <!-- Simple link --> < a href = \"https://www.example.com\" target = \"_blank\" > Open link in new tab </ a > <!-- Open in new tab --> < a href = \"mailto:someone@example.com\" > Send Email </ a > <!-- Email link --> < a href = \"tel:+1234567890\" > Call Number </ a > <!-- Phone link --> Lists Unordered List < ul > < li > Item 1 </ li > < li > Item 2 </ li > < li > Item 3 </ li > </ ul > Ordered List < ol > < li > First item </ li > < li > Second item </ li > < li > Third item </ li > </ ol > Definition List < dl > < dt > Term 1 </ dt > < dd > Definition of Term 1 </ dd > < dt > Term 2 </ dt > < dd > Definition of Term 2 </ dd > </ dl > Images < img src = \"image.jpg\" alt = \"Description of Image\" > <!-- Basic image --> < img src = \"image.jpg\" alt = \"Description of Image\" width = \"500\" height = \"600\" > <!-- Image with size --> Tables < table > < tr > < th > Header 1 </ th > < th > Header 2 </ th > </ tr > < tr > < td > Data 1 </ td > < td > Data 2 </ td > </ tr > </ table > Forms < form action = \"/submit-form\" method = \"post\" > < label for = \"name\" > Name: </ label > < input type = \"text\" id = \"name\" name = \"name\" > < label for = \"email\" > Email: </ label > < input type = \"email\" id = \"email\" name = \"email\" > < input type = \"submit\" value = \"Submit\" > </ form > Common Form Elements < input type = \"text\" placeholder = \"Text input\" > <!-- Single-line text input --> < input type = \"password\" placeholder = \"Password\" > <!-- Password input --> < input type = \"email\" placeholder = \"Email address\" > <!-- Email input --> < textarea placeholder = \"Multi-line text input\" ></ textarea > <!-- Multi-line text input --> < select > < option value = \"option1\" > Option 1 </ option > < option value = \"option2\" > Option 2 </ option > </ select > <!-- Drop-down list --> < input type = \"radio\" name = \"radio\" value = \"option1\" > Option 1 <!-- Radio button --> < input type = \"checkbox\" name = \"checkbox\" value = \"option1\" > Option 1 <!-- Checkbox --> Semantic HTML < header > <!-- Header content --> </ header > < nav > <!-- Navigation links --> </ nav > < main > <!-- Main content --> </ main > < article > <!-- Article content --> </ article > < section > <!-- Section content --> </ section > < aside > <!-- Sidebar content --> </ aside > < footer > <!-- Footer content --> </ footer > Media Audio < audio controls > < source src = \"audio.mp3\" type = \"audio/mpeg\" > Your browser does not support the audio element. </ audio > Video < video controls > < source src = \"video.mp4\" type = \"video/mp4\" > Your browser does not support the video element. </ video > Embedding Iframe < iframe src = \"https://www.example.com\" title = \"Iframe Example\" ></ iframe > Embed < embed src = \"file.pdf\" type = \"application/pdf\" > Object < object data = \"file.pdf\" type = \"application/pdf\" > < p > Alternative text for browsers that do not support the object element. </ p > </ object > Scripting Internal JavaScript < script > console . log ( 'Hello, world!' ); </ script > External JavaScript < script src = \"script.js\" ></ script > Meta Tags < meta charset = \"UTF-8\" > <!-- Character encoding --> < meta name = \"viewport\" content = \"width=device-width, initial-scale=1.0\" > <!-- Responsive design --> < meta name = \"description\" content = \"Description of the webpage\" > <!-- Description --> < meta name = \"keywords\" content = \"HTML, CSS, JavaScript\" > <!-- Keywords --> < meta name = \"author\" content = \"Author Name\" > <!-- Author --> Miscellaneous Comments <!-- This is a comment --> Doctype <!DOCTYPE html> Character Encoding < meta charset = \"UTF-8\" > HTML Entities < <!-- Less than --> > <!-- Greater than --> & <!-- Ampersand --> \" <!-- Double quote --> ' <!-- Single quote --> \u00a9 <!-- Copyright --> \u00ae <!-- Registered trademark --> <!-- Non-breaking space --> This cheat sheet covers a broad range of basic and advanced HTML elements and attributes. Feel free to expand it with more specific tags and use cases as needed!","title":"Index"},{"location":"#document-metadata","text":"<!DOCTYPE html> <!-- Document type declaration --> < html lang = \"en\" > <!-- Sets the language of the document --> < head > < meta charset = \"UTF-8\" > <!-- Character encoding --> < meta name = \"viewport\" content = \"width=device-width, initial-scale=1.0\" > <!-- Responsive design --> < title > Document </ title > <!-- Document title --> </ head > < body > <!-- Body content --> </ body > </ html >","title":"Document Metadata"},{"location":"#headings","text":"< h1 > This is a Heading 1 </ h1 > < h2 > This is a Heading 2 </ h2 > < h3 > This is a Heading 3 </ h3 > < h4 > This is a Heading 4 </ h4 > < h5 > This is a Heading 5 </ h5 > < h6 > This is a Heading 6 </ h6 >","title":"Headings"},{"location":"#paragraphs-and-line-breaks","text":"< p > This is a paragraph. </ p > < p > This is another paragraph. </ p > < p > This is a paragraph with a < br > line break. </ p >","title":"Paragraphs and Line Breaks"},{"location":"#text-formatting","text":"< b > Bold </ b > or < strong > Strong </ strong > <!-- Bold text --> < i > Italic </ i > or < em > Emphasized </ em > <!-- Italic text --> < u > Underline </ u > <!-- Underlined text --> < del > Deleted </ del > <!-- Strikethrough text --> < mark > Highlighted </ mark > <!-- Highlighted text --> < sup > Superscript </ sup > <!-- Superscript text --> < sub > Subscript </ sub > <!-- Subscript text -->","title":"Text Formatting"},{"location":"#links","text":"< a href = \"https://www.example.com\" > This is a link </ a > <!-- Simple link --> < a href = \"https://www.example.com\" target = \"_blank\" > Open link in new tab </ a > <!-- Open in new tab --> < a href = \"mailto:someone@example.com\" > Send Email </ a > <!-- Email link --> < a href = \"tel:+1234567890\" > Call Number </ a > <!-- Phone link -->","title":"Links"},{"location":"#lists","text":"","title":"Lists"},{"location":"#unordered-list","text":"< ul > < li > Item 1 </ li > < li > Item 2 </ li > < li > Item 3 </ li > </ ul >","title":"Unordered List"},{"location":"#ordered-list","text":"< ol > < li > First item </ li > < li > Second item </ li > < li > Third item </ li > </ ol >","title":"Ordered List"},{"location":"#definition-list","text":"< dl > < dt > Term 1 </ dt > < dd > Definition of Term 1 </ dd > < dt > Term 2 </ dt > < dd > Definition of Term 2 </ dd > </ dl >","title":"Definition List"},{"location":"#images","text":"< img src = \"image.jpg\" alt = \"Description of Image\" > <!-- Basic image --> < img src = \"image.jpg\" alt = \"Description of Image\" width = \"500\" height = \"600\" > <!-- Image with size -->","title":"Images"},{"location":"#tables","text":"< table > < tr > < th > Header 1 </ th > < th > Header 2 </ th > </ tr > < tr > < td > Data 1 </ td > < td > Data 2 </ td > </ tr > </ table >","title":"Tables"},{"location":"#forms","text":"< form action = \"/submit-form\" method = \"post\" > < label for = \"name\" > Name: </ label > < input type = \"text\" id = \"name\" name = \"name\" > < label for = \"email\" > Email: </ label > < input type = \"email\" id = \"email\" name = \"email\" > < input type = \"submit\" value = \"Submit\" > </ form >","title":"Forms"},{"location":"#common-form-elements","text":"< input type = \"text\" placeholder = \"Text input\" > <!-- Single-line text input --> < input type = \"password\" placeholder = \"Password\" > <!-- Password input --> < input type = \"email\" placeholder = \"Email address\" > <!-- Email input --> < textarea placeholder = \"Multi-line text input\" ></ textarea > <!-- Multi-line text input --> < select > < option value = \"option1\" > Option 1 </ option > < option value = \"option2\" > Option 2 </ option > </ select > <!-- Drop-down list --> < input type = \"radio\" name = \"radio\" value = \"option1\" > Option 1 <!-- Radio button --> < input type = \"checkbox\" name = \"checkbox\" value = \"option1\" > Option 1 <!-- Checkbox -->","title":"Common Form Elements"},{"location":"#semantic-html","text":"< header > <!-- Header content --> </ header > < nav > <!-- Navigation links --> </ nav > < main > <!-- Main content --> </ main > < article > <!-- Article content --> </ article > < section > <!-- Section content --> </ section > < aside > <!-- Sidebar content --> </ aside > < footer > <!-- Footer content --> </ footer >","title":"Semantic HTML"},{"location":"#media","text":"","title":"Media"},{"location":"#audio","text":"< audio controls > < source src = \"audio.mp3\" type = \"audio/mpeg\" > Your browser does not support the audio element. </ audio >","title":"Audio"},{"location":"#video","text":"< video controls > < source src = \"video.mp4\" type = \"video/mp4\" > Your browser does not support the video element. </ video >","title":"Video"},{"location":"#embedding","text":"","title":"Embedding"},{"location":"#iframe","text":"< iframe src = \"https://www.example.com\" title = \"Iframe Example\" ></ iframe >","title":"Iframe"},{"location":"#embed","text":"< embed src = \"file.pdf\" type = \"application/pdf\" >","title":"Embed"},{"location":"#object","text":"< object data = \"file.pdf\" type = \"application/pdf\" > < p > Alternative text for browsers that do not support the object element. </ p > </ object >","title":"Object"},{"location":"#scripting","text":"","title":"Scripting"},{"location":"#internal-javascript","text":"< script > console . log ( 'Hello, world!' ); </ script >","title":"Internal JavaScript"},{"location":"#external-javascript","text":"< script src = \"script.js\" ></ script >","title":"External JavaScript"},{"location":"#meta-tags","text":"< meta charset = \"UTF-8\" > <!-- Character encoding --> < meta name = \"viewport\" content = \"width=device-width, initial-scale=1.0\" > <!-- Responsive design --> < meta name = \"description\" content = \"Description of the webpage\" > <!-- Description --> < meta name = \"keywords\" content = \"HTML, CSS, JavaScript\" > <!-- Keywords --> < meta name = \"author\" content = \"Author Name\" > <!-- Author -->","title":"Meta Tags"},{"location":"#miscellaneous","text":"","title":"Miscellaneous"},{"location":"#comments","text":"<!-- This is a comment -->","title":"Comments"},{"location":"#doctype","text":"<!DOCTYPE html>","title":"Doctype"},{"location":"#character-encoding","text":"< meta charset = \"UTF-8\" >","title":"Character Encoding"},{"location":"#html-entities","text":"< <!-- Less than --> > <!-- Greater than --> & <!-- Ampersand --> \" <!-- Double quote --> ' <!-- Single quote --> \u00a9 <!-- Copyright --> \u00ae <!-- Registered trademark --> <!-- Non-breaking space --> This cheat sheet covers a broad range of basic and advanced HTML elements and attributes. Feel free to expand it with more specific tags and use cases as needed!","title":"HTML Entities"},{"location":"Flask/","text":"comprehensive Flask cheat sheet : # Flask Cheat Sheet ## Setup ### Installation ```sh pip install Flask Basic Structure from flask import Flask app = Flask ( __name__ ) @app . route ( '/' ) def home (): return \"Hello, Flask!\" if __name__ == '__main__' : app . run ( debug = True ) Routes Basic Route @app . route ( '/' ) def home (): return \"Home Page ### Route with Variable ``` python @app . route ( '/user/<username>' ) def show_user ( username ): return f \"User: { username } \" Variable Types @app . route ( '/post/<int:post_id>' ) def show_post ( post_id ): return f \"Post ID: { post_id } \" HTTP Methods @app . route ( '/login' , methods = [ 'GET' , 'POST' ]) def login (): if request . method == 'POST' : return \"Logging in...\" else : return \"Login Page\" Rendering Templates HTML Template Create a directory called templates and a file index.html inside it: <!DOCTYPE html> < html > < head > < title > Home Page </ title > </ head > < body > < h1 > {{ title }} </ h1 > < p > {{ message }} </ p > </ body > </ html > Render Template from flask import render_template @app . route ( '/' ) def home (): return render_template ( 'index.html' , title = 'Home' , message = 'Welcome to Flask!' ) Template Inheritance Base Template ( base.html ) <!DOCTYPE html> < html > < head > < title > {% block title %}{% endblock %} </ title > </ head > < body > {% block content %}{% endblock %} </ body > </ html > Child Template ( child.html ) {% extends \"base.html\" %} {% block title %}Child Page{% endblock %} {% block content %} < h1 > This is the child page. </ h1 > {% endblock %} Render Child Template @app . route ( '/child' ) def child (): return render_template ( 'child.html' ) Static Files Serving Static Files Place your static files (CSS, JS, images) in the static directory. Accessing Static Files < link rel = \"stylesheet\" type = \"text/css\" href = \"{{ url_for('static', filename='style.css') }}\" > Forms and Request Data Simple Form < form method = \"POST\" action = \"/submit\" > < input type = \"text\" name = \"username\" > < input type = \"submit\" value = \"Submit\" > </ form > Handling Form Submission from flask import request @app . route ( '/submit' , methods = [ 'POST' ]) def submit (): username = request . form [ 'username' ] return f \"Submitted: { username } \" Redirects and URLs Redirect from flask import redirect @app . route ( '/go-to-home' ) def go_to_home (): return redirect ( '/' ) URL Generation from flask import url_for @app . route ( '/admin' ) def admin (): return redirect ( url_for ( 'home' )) Flash Messages Setting Up Flash Messages from flask import flash @app . route ( '/flash-example' ) def flash_example (): flash ( 'This is a flash message.' ) return redirect ( '/' ) Displaying Flash Messages In your template (e.g., index.html ): {% with messages = get_flashed_messages() %} {% if messages %} < ul > {% for message in messages %} < li > {{ message }} </ li > {% endfor %} </ ul > {% endif %} {% endwith %} Sessions Using Sessions from flask import session app . secret_key = 'supersecretkey' @app . route ( '/set-session' ) def set_session (): session [ 'username' ] = 'admin' return 'Session set!' @app . route ( '/get-session' ) def get_session (): username = session . get ( 'username' ) return f 'Session username: { username } ' Error Handling Custom Error Pages @app . errorhandler ( 404 ) def page_not_found ( e ): return render_template ( '404.html' ), 404 404 Template ( 404.html ) <!DOCTYPE html> < html > < head > < title > Page Not Found </ title > </ head > < body > < h1 > 404 - Page Not Found </ h1 > < p > The page you are looking for does not exist. </ p > </ body > </ html > JSON Responses Returning JSON from flask import jsonify @app . route ( '/api/data' ) def get_data (): data = { 'key' : 'value' } return jsonify ( data ) Database Integration (Flask-SQLAlchemy) Installation pip install Flask-SQLAlchemy Setup from flask_sqlalchemy import SQLAlchemy app . config [ 'SQLALCHEMY_DATABASE_URI' ] = 'sqlite:///site.db' db = SQLAlchemy ( app ) class User ( db . Model ): id = db . Column ( db . Integer , primary_key = True ) username = db . Column ( db . String ( 150 ), nullable = False ) @app . route ( '/add-user' ) def add_user (): user = User ( username = 'admin' ) db . session . add ( user ) db . session . commit () return 'User added!' Flask Extensions Flask-Migrate pip install Flask-Migrate Setup Flask-Migrate from flask_migrate import Migrate migrate = Migrate ( app , db ) # Run migrations # flask db init # flask db migrate -m \"Initial migration.\" # flask db upgrade Running the App Run the Development Server export FLASK_APP = app.py export FLASK_ENV = development flask run This cheat sheet covers the essential elements and features of Flask for quick reference. Feel free to expand it with more specific use cases and Flask extensions as needed!","title":"Flask"},{"location":"Flask/#basic-structure","text":"from flask import Flask app = Flask ( __name__ ) @app . route ( '/' ) def home (): return \"Hello, Flask!\" if __name__ == '__main__' : app . run ( debug = True )","title":"Basic Structure"},{"location":"Flask/#routes","text":"","title":"Routes"},{"location":"Flask/#basic-route","text":"@app . route ( '/' ) def home (): return \"Home Page ### Route with Variable ``` python @app . route ( '/user/<username>' ) def show_user ( username ): return f \"User: { username } \"","title":"Basic Route"},{"location":"Flask/#variable-types","text":"@app . route ( '/post/<int:post_id>' ) def show_post ( post_id ): return f \"Post ID: { post_id } \"","title":"Variable Types"},{"location":"Flask/#http-methods","text":"@app . route ( '/login' , methods = [ 'GET' , 'POST' ]) def login (): if request . method == 'POST' : return \"Logging in...\" else : return \"Login Page\"","title":"HTTP Methods"},{"location":"Flask/#rendering-templates","text":"","title":"Rendering Templates"},{"location":"Flask/#html-template","text":"Create a directory called templates and a file index.html inside it: <!DOCTYPE html> < html > < head > < title > Home Page </ title > </ head > < body > < h1 > {{ title }} </ h1 > < p > {{ message }} </ p > </ body > </ html >","title":"HTML Template"},{"location":"Flask/#render-template","text":"from flask import render_template @app . route ( '/' ) def home (): return render_template ( 'index.html' , title = 'Home' , message = 'Welcome to Flask!' )","title":"Render Template"},{"location":"Flask/#template-inheritance","text":"","title":"Template Inheritance"},{"location":"Flask/#base-template-basehtml","text":"<!DOCTYPE html> < html > < head > < title > {% block title %}{% endblock %} </ title > </ head > < body > {% block content %}{% endblock %} </ body > </ html >","title":"Base Template (base.html)"},{"location":"Flask/#child-template-childhtml","text":"{% extends \"base.html\" %} {% block title %}Child Page{% endblock %} {% block content %} < h1 > This is the child page. </ h1 > {% endblock %}","title":"Child Template (child.html)"},{"location":"Flask/#render-child-template","text":"@app . route ( '/child' ) def child (): return render_template ( 'child.html' )","title":"Render Child Template"},{"location":"Flask/#static-files","text":"","title":"Static Files"},{"location":"Flask/#serving-static-files","text":"Place your static files (CSS, JS, images) in the static directory.","title":"Serving Static Files"},{"location":"Flask/#accessing-static-files","text":"< link rel = \"stylesheet\" type = \"text/css\" href = \"{{ url_for('static', filename='style.css') }}\" >","title":"Accessing Static Files"},{"location":"Flask/#forms-and-request-data","text":"","title":"Forms and Request Data"},{"location":"Flask/#simple-form","text":"< form method = \"POST\" action = \"/submit\" > < input type = \"text\" name = \"username\" > < input type = \"submit\" value = \"Submit\" > </ form >","title":"Simple Form"},{"location":"Flask/#handling-form-submission","text":"from flask import request @app . route ( '/submit' , methods = [ 'POST' ]) def submit (): username = request . form [ 'username' ] return f \"Submitted: { username } \"","title":"Handling Form Submission"},{"location":"Flask/#redirects-and-urls","text":"","title":"Redirects and URLs"},{"location":"Flask/#redirect","text":"from flask import redirect @app . route ( '/go-to-home' ) def go_to_home (): return redirect ( '/' )","title":"Redirect"},{"location":"Flask/#url-generation","text":"from flask import url_for @app . route ( '/admin' ) def admin (): return redirect ( url_for ( 'home' ))","title":"URL Generation"},{"location":"Flask/#flash-messages","text":"","title":"Flash Messages"},{"location":"Flask/#setting-up-flash-messages","text":"from flask import flash @app . route ( '/flash-example' ) def flash_example (): flash ( 'This is a flash message.' ) return redirect ( '/' )","title":"Setting Up Flash Messages"},{"location":"Flask/#displaying-flash-messages","text":"In your template (e.g., index.html ): {% with messages = get_flashed_messages() %} {% if messages %} < ul > {% for message in messages %} < li > {{ message }} </ li > {% endfor %} </ ul > {% endif %} {% endwith %}","title":"Displaying Flash Messages"},{"location":"Flask/#sessions","text":"","title":"Sessions"},{"location":"Flask/#using-sessions","text":"from flask import session app . secret_key = 'supersecretkey' @app . route ( '/set-session' ) def set_session (): session [ 'username' ] = 'admin' return 'Session set!' @app . route ( '/get-session' ) def get_session (): username = session . get ( 'username' ) return f 'Session username: { username } '","title":"Using Sessions"},{"location":"Flask/#error-handling","text":"","title":"Error Handling"},{"location":"Flask/#custom-error-pages","text":"@app . errorhandler ( 404 ) def page_not_found ( e ): return render_template ( '404.html' ), 404","title":"Custom Error Pages"},{"location":"Flask/#404-template-404html","text":"<!DOCTYPE html> < html > < head > < title > Page Not Found </ title > </ head > < body > < h1 > 404 - Page Not Found </ h1 > < p > The page you are looking for does not exist. </ p > </ body > </ html >","title":"404 Template (404.html)"},{"location":"Flask/#json-responses","text":"","title":"JSON Responses"},{"location":"Flask/#returning-json","text":"from flask import jsonify @app . route ( '/api/data' ) def get_data (): data = { 'key' : 'value' } return jsonify ( data )","title":"Returning JSON"},{"location":"Flask/#database-integration-flask-sqlalchemy","text":"","title":"Database Integration (Flask-SQLAlchemy)"},{"location":"Flask/#installation","text":"pip install Flask-SQLAlchemy","title":"Installation"},{"location":"Flask/#setup","text":"from flask_sqlalchemy import SQLAlchemy app . config [ 'SQLALCHEMY_DATABASE_URI' ] = 'sqlite:///site.db' db = SQLAlchemy ( app ) class User ( db . Model ): id = db . Column ( db . Integer , primary_key = True ) username = db . Column ( db . String ( 150 ), nullable = False ) @app . route ( '/add-user' ) def add_user (): user = User ( username = 'admin' ) db . session . add ( user ) db . session . commit () return 'User added!'","title":"Setup"},{"location":"Flask/#flask-extensions","text":"","title":"Flask Extensions"},{"location":"Flask/#flask-migrate","text":"pip install Flask-Migrate","title":"Flask-Migrate"},{"location":"Flask/#setup-flask-migrate","text":"from flask_migrate import Migrate migrate = Migrate ( app , db ) # Run migrations # flask db init # flask db migrate -m \"Initial migration.\" # flask db upgrade","title":"Setup Flask-Migrate"},{"location":"Flask/#running-the-app","text":"","title":"Running the App"},{"location":"Flask/#run-the-development-server","text":"export FLASK_APP = app.py export FLASK_ENV = development flask run This cheat sheet covers the essential elements and features of Flask for quick reference. Feel free to expand it with more specific use cases and Flask extensions as needed!","title":"Run the Development Server"},{"location":"css/","text":"comprehensive CSS cheat sheet # CSS Cheat Sheet ## Basic Syntax ```css selector { property: value; } Selectors Universal Selector * { margin : 0 ; padding : 0 ; } Element Selector p { color : blue ; } Class Selector . className { font-size : 14 px ; } ID Selector # idName { background-color : yellow ; } Attribute Selector input [ type = \"text\" ] { border : 1 px solid #000 ; } Pseudo-class Selector a : hover { color : red ; } Pseudo-element Selector p :: first-line { font-weight : bold ; } Box Model Margin div { margin : 20 px ; margin-top : 10 px ; margin-right : 15 px ; margin-bottom : 10 px ; margin-left : 5 px ; } Padding div { padding : 20 px ; padding-top : 10 px ; padding-right : 15 px ; padding-bottom : 10 px ; padding-left : 5 px ; } Border div { border : 1 px solid black ; border-width : 2 px ; border-style : dashed ; border-color : blue ; } Width and Height div { width : 100 px ; height : 50 px ; } Background body { background-color : #f0f0f0 ; background-image : url ( 'background.jpg' ); background-repeat : no-repeat ; background-attachment : fixed ; background-position : center ; background-size : cover ; } Text Color p { color : #333 ; } Font p { font-family : Arial , sans-serif ; font-size : 16 px ; font-weight : bold ; font-style : italic ; line-height : 1.5 ; text-align : center ; text-decoration : underline ; text-transform : uppercase ; text-indent : 50 px ; letter-spacing : 2 px ; word-spacing : 5 px ; } Lists Unordered List ul { list-style-type : disc ; list-style-position : inside ; } Ordered List ol { list-style-type : decimal ; list-style-position : outside ; } Display and Positioning Display div { display : none ; /* block, inline, inline-block, flex, grid */ } Position div { position : static ; /* relative, absolute, fixed, sticky */ top : 10 px ; right : 10 px ; bottom : 10 px ; left : 10 px ; } Float and Clear div { float : left ; /* right, none */ clear : both ; /* left, right, none */ } Z-index div { position : relative ; z-index : 10 ; } Flexbox Container . container { display : flex ; flex-direction : row ; /* row-reverse, column, column-reverse */ flex-wrap : nowrap ; /* wrap, wrap-reverse */ justify-content : flex-start ; /* center, flex-end, space-between, space-around, space-evenly */ align-items : stretch ; /* flex-start, center, flex-end, baseline */ align-content : stretch ; /* flex-start, center, flex-end, space-between, space-around */ } Item . item { flex : 0 1 auto ; /* flex-grow, flex-shrink, flex-basis */ align-self : auto ; /* flex-start, center, flex-end, baseline, stretch */ order : 0 ; } Grid Container . container { display : grid ; grid-template-columns : repeat ( 3 , 1 fr ); /* or 100px 1fr 2fr */ grid-template-rows : repeat ( 2 , auto ); /* or 100px 200px */ gap : 10 px ; /* row-gap, column-gap */ grid-auto-flow : row ; /* column, dense */ } Item . item { grid-column : 1 / 3 ; /* or span 2 */ grid-row : 1 / 2 ; /* or span 1 */ justify-self : center ; /* start, end, stretch */ align-self : center ; /* start, end, stretch */ } Media Queries @ media ( max-width : 600px ) { body { background-color : lightblue ; } } Animations Keyframes @ keyframes example { from { background-color : red ;} to { background-color : yellow ;} } Animation div { animation-name : example ; animation-duration : 4 s ; animation-timing-function : linear ; /* ease, ease-in, ease-out, ease-in-out */ animation-delay : 2 s ; animation-iteration-count : infinite ; /* or a number */ animation-direction : alternate ; /* normal, reverse, alternate-reverse */ animation-fill-mode : forwards ; /* none, backwards, both */ animation-play-state : running ; /* paused */ } Transitions div { transition-property : background-color ; transition-duration : 2 s ; transition-timing-function : ease-in-out ; /* linear, ease, ease-in, ease-out */ transition-delay : 1 s ; } Transform div { transform : translate ( 50 px , 100 px ); transform : rotate ( 45 deg ); transform : scale ( 1.5 ); transform : skew ( 20 deg , 10 deg ); transform-origin : top left ; } Variables : root { --main-color : #06c ; --padding : 10 px ; } div { color : var ( --main-color ); padding : var ( --padding ); } Miscellaneous Overflow div { overflow : hidden ; /* auto, scroll, visible */ } Opacity div { opacity : 0.5 ; } Visibility div { visibility : hidden ; /* visible, collapse */ } Cursor div { cursor : pointer ; /* default, crosshair, text, wait, help, not-allowed, etc. */ } Box Shadow div { box-shadow : 10 px 10 px 5 px #888888 ; } Text Shadow p { text-shadow : 2 px 2 px 5 px #555555 ; } Outline div { outline : 2 px solid red ; outline-offset : 5 px ; } This CSS cheat sheet covers a wide range of CSS properties and techniques. Feel free to expand it with more specific properties and use cases as needed!","title":"Css"},{"location":"css/#selectors","text":"","title":"Selectors"},{"location":"css/#universal-selector","text":"* { margin : 0 ; padding : 0 ; }","title":"Universal Selector"},{"location":"css/#element-selector","text":"p { color : blue ; }","title":"Element Selector"},{"location":"css/#class-selector","text":". className { font-size : 14 px ; }","title":"Class Selector"},{"location":"css/#id-selector","text":"# idName { background-color : yellow ; }","title":"ID Selector"},{"location":"css/#attribute-selector","text":"input [ type = \"text\" ] { border : 1 px solid #000 ; }","title":"Attribute Selector"},{"location":"css/#pseudo-class-selector","text":"a : hover { color : red ; }","title":"Pseudo-class Selector"},{"location":"css/#pseudo-element-selector","text":"p :: first-line { font-weight : bold ; }","title":"Pseudo-element Selector"},{"location":"css/#box-model","text":"","title":"Box Model"},{"location":"css/#margin","text":"div { margin : 20 px ; margin-top : 10 px ; margin-right : 15 px ; margin-bottom : 10 px ; margin-left : 5 px ; }","title":"Margin"},{"location":"css/#padding","text":"div { padding : 20 px ; padding-top : 10 px ; padding-right : 15 px ; padding-bottom : 10 px ; padding-left : 5 px ; }","title":"Padding"},{"location":"css/#border","text":"div { border : 1 px solid black ; border-width : 2 px ; border-style : dashed ; border-color : blue ; }","title":"Border"},{"location":"css/#width-and-height","text":"div { width : 100 px ; height : 50 px ; }","title":"Width and Height"},{"location":"css/#background","text":"body { background-color : #f0f0f0 ; background-image : url ( 'background.jpg' ); background-repeat : no-repeat ; background-attachment : fixed ; background-position : center ; background-size : cover ; }","title":"Background"},{"location":"css/#text","text":"","title":"Text"},{"location":"css/#color","text":"p { color : #333 ; }","title":"Color"},{"location":"css/#font","text":"p { font-family : Arial , sans-serif ; font-size : 16 px ; font-weight : bold ; font-style : italic ; line-height : 1.5 ; text-align : center ; text-decoration : underline ; text-transform : uppercase ; text-indent : 50 px ; letter-spacing : 2 px ; word-spacing : 5 px ; }","title":"Font"},{"location":"css/#lists","text":"","title":"Lists"},{"location":"css/#unordered-list","text":"ul { list-style-type : disc ; list-style-position : inside ; }","title":"Unordered List"},{"location":"css/#ordered-list","text":"ol { list-style-type : decimal ; list-style-position : outside ; }","title":"Ordered List"},{"location":"css/#display-and-positioning","text":"","title":"Display and Positioning"},{"location":"css/#display","text":"div { display : none ; /* block, inline, inline-block, flex, grid */ }","title":"Display"},{"location":"css/#position","text":"div { position : static ; /* relative, absolute, fixed, sticky */ top : 10 px ; right : 10 px ; bottom : 10 px ; left : 10 px ; }","title":"Position"},{"location":"css/#float-and-clear","text":"div { float : left ; /* right, none */ clear : both ; /* left, right, none */ }","title":"Float and Clear"},{"location":"css/#z-index","text":"div { position : relative ; z-index : 10 ; }","title":"Z-index"},{"location":"css/#flexbox","text":"","title":"Flexbox"},{"location":"css/#container","text":". container { display : flex ; flex-direction : row ; /* row-reverse, column, column-reverse */ flex-wrap : nowrap ; /* wrap, wrap-reverse */ justify-content : flex-start ; /* center, flex-end, space-between, space-around, space-evenly */ align-items : stretch ; /* flex-start, center, flex-end, baseline */ align-content : stretch ; /* flex-start, center, flex-end, space-between, space-around */ }","title":"Container"},{"location":"css/#item","text":". item { flex : 0 1 auto ; /* flex-grow, flex-shrink, flex-basis */ align-self : auto ; /* flex-start, center, flex-end, baseline, stretch */ order : 0 ; }","title":"Item"},{"location":"css/#grid","text":"","title":"Grid"},{"location":"css/#container_1","text":". container { display : grid ; grid-template-columns : repeat ( 3 , 1 fr ); /* or 100px 1fr 2fr */ grid-template-rows : repeat ( 2 , auto ); /* or 100px 200px */ gap : 10 px ; /* row-gap, column-gap */ grid-auto-flow : row ; /* column, dense */ }","title":"Container"},{"location":"css/#item_1","text":". item { grid-column : 1 / 3 ; /* or span 2 */ grid-row : 1 / 2 ; /* or span 1 */ justify-self : center ; /* start, end, stretch */ align-self : center ; /* start, end, stretch */ }","title":"Item"},{"location":"css/#media-queries","text":"@ media ( max-width : 600px ) { body { background-color : lightblue ; } }","title":"Media Queries"},{"location":"css/#animations","text":"","title":"Animations"},{"location":"css/#keyframes","text":"@ keyframes example { from { background-color : red ;} to { background-color : yellow ;} }","title":"Keyframes"},{"location":"css/#animation","text":"div { animation-name : example ; animation-duration : 4 s ; animation-timing-function : linear ; /* ease, ease-in, ease-out, ease-in-out */ animation-delay : 2 s ; animation-iteration-count : infinite ; /* or a number */ animation-direction : alternate ; /* normal, reverse, alternate-reverse */ animation-fill-mode : forwards ; /* none, backwards, both */ animation-play-state : running ; /* paused */ }","title":"Animation"},{"location":"css/#transitions","text":"div { transition-property : background-color ; transition-duration : 2 s ; transition-timing-function : ease-in-out ; /* linear, ease, ease-in, ease-out */ transition-delay : 1 s ; }","title":"Transitions"},{"location":"css/#transform","text":"div { transform : translate ( 50 px , 100 px ); transform : rotate ( 45 deg ); transform : scale ( 1.5 ); transform : skew ( 20 deg , 10 deg ); transform-origin : top left ; }","title":"Transform"},{"location":"css/#variables","text":": root { --main-color : #06c ; --padding : 10 px ; } div { color : var ( --main-color ); padding : var ( --padding ); }","title":"Variables"},{"location":"css/#miscellaneous","text":"","title":"Miscellaneous"},{"location":"css/#overflow","text":"div { overflow : hidden ; /* auto, scroll, visible */ }","title":"Overflow"},{"location":"css/#opacity","text":"div { opacity : 0.5 ; }","title":"Opacity"},{"location":"css/#visibility","text":"div { visibility : hidden ; /* visible, collapse */ }","title":"Visibility"},{"location":"css/#cursor","text":"div { cursor : pointer ; /* default, crosshair, text, wait, help, not-allowed, etc. */ }","title":"Cursor"},{"location":"css/#box-shadow","text":"div { box-shadow : 10 px 10 px 5 px #888888 ; }","title":"Box Shadow"},{"location":"css/#text-shadow","text":"p { text-shadow : 2 px 2 px 5 px #555555 ; }","title":"Text Shadow"},{"location":"css/#outline","text":"div { outline : 2 px solid red ; outline-offset : 5 px ; } This CSS cheat sheet covers a wide range of CSS properties and techniques. Feel free to expand it with more specific properties and use cases as needed!","title":"Outline"},{"location":"Week%206/Rest_lec6_2/","text":"REST (REpresentational State Transfer) REST is a software architecture style for distributed systems on the web. REST defines a set of constraints that guide the design of web services. REST is based on the idea of representing state in the form of resources that are transferred between clients and servers. REST Sequence Client accesses a Resource Identifier from server: Typically a URI (Uniform Resource Identifier). Resource Operation specified as part of access: E.g., GET, POST, PUT, DELETE. Server responds with new Resource Identifier: New state of system and links to follow. Using HTTP with REST HTTP (Hypertext Transfer Protocol) is a protocol that can be used to carry REST messages. HTTP verbs (e.g., GET, POST, PUT, DELETE) are used to indicate actions. HTTP provides standardized functionality. Using JSON with REST JSON (JavaScript Object Notation) is a data format that is commonly used with REST APIs. JSON is a lightweight and easy-to-read format that can represent complex data structures. API Data Transfer Format Input to API: Text (e.g., HTTP) Output: Complex data types (e.g., JSON, XML) Different from internal server representation Different from final view presentation Examples of REST APIs Wikipedia: Search for pages, view page history, and retrieve JSON output CoWin: Book vaccine appointments, search for vaccination centers Twitter: Post tweets, view timelines, and follow users Typical Functionality REST APIs typically offer a range of functionalities, including: CRUD operations (Create, Read, Update, Delete) Listing (querying and filtering data) Specialized functions (e.g., creating virtual machines, rebooting servers) Formal Specifications Formal specifications, such as OpenAPI, help developers understand and use REST APIs effectively. They define the endpoint URLs, request and response formats, and error codes. Authentication Many APIs require authentication to protect user data and prevent abuse. Common authentication methods include: Tokens: Unique identifiers issued to valid users API Keys: One-time tokens that can be downloaded by users Benefits of REST APIs Interoperability: Allows seamless integration with third-party applications Simplified development: Provides a clear and concise design framework Scalability: Supports high volumes of requests without compromising performance Detailed Documentation Comprehensive documentation is essential for understanding the capabilities of a REST API. It includes: Endpoint URLs and parameters Request and response formats Error codes and handling Testing REST APIs To ensure proper functioning, REST APIs should be thoroughly tested. This can be done using tools like curl or Postman. However, excessive testing should be avoided to prevent overloading servers. Summary REST APIs are powerful tools for creating web services that can be accessed and integrated by various applications. They offer a wide range of functionalities, including CRUD operations, listing, and specialized functions. Authentication mechanisms ensure data protection and prevent abuse. Formal specifications provide guidance for developers, and detailed documentation simplifies API implementation. By leveraging REST APIs, developers can create interoperable, scalable, and user-friendly systems.","title":"Rest lec6 2"},{"location":"Week%206/Rest_lec6_2/#rest-representational-state-transfer","text":"REST is a software architecture style for distributed systems on the web. REST defines a set of constraints that guide the design of web services. REST is based on the idea of representing state in the form of resources that are transferred between clients and servers.","title":"REST (REpresentational State Transfer)"},{"location":"Week%206/Rest_lec6_2/#rest-sequence","text":"Client accesses a Resource Identifier from server: Typically a URI (Uniform Resource Identifier). Resource Operation specified as part of access: E.g., GET, POST, PUT, DELETE. Server responds with new Resource Identifier: New state of system and links to follow.","title":"REST Sequence"},{"location":"Week%206/Rest_lec6_2/#using-http-with-rest","text":"HTTP (Hypertext Transfer Protocol) is a protocol that can be used to carry REST messages. HTTP verbs (e.g., GET, POST, PUT, DELETE) are used to indicate actions. HTTP provides standardized functionality.","title":"Using HTTP with REST"},{"location":"Week%206/Rest_lec6_2/#using-json-with-rest","text":"JSON (JavaScript Object Notation) is a data format that is commonly used with REST APIs. JSON is a lightweight and easy-to-read format that can represent complex data structures.","title":"Using JSON with REST"},{"location":"Week%206/Rest_lec6_2/#api-data-transfer-format","text":"Input to API: Text (e.g., HTTP) Output: Complex data types (e.g., JSON, XML) Different from internal server representation Different from final view presentation Examples of REST APIs Wikipedia: Search for pages, view page history, and retrieve JSON output CoWin: Book vaccine appointments, search for vaccination centers Twitter: Post tweets, view timelines, and follow users Typical Functionality REST APIs typically offer a range of functionalities, including: CRUD operations (Create, Read, Update, Delete) Listing (querying and filtering data) Specialized functions (e.g., creating virtual machines, rebooting servers) Formal Specifications Formal specifications, such as OpenAPI, help developers understand and use REST APIs effectively. They define the endpoint URLs, request and response formats, and error codes. Authentication Many APIs require authentication to protect user data and prevent abuse. Common authentication methods include: Tokens: Unique identifiers issued to valid users API Keys: One-time tokens that can be downloaded by users Benefits of REST APIs Interoperability: Allows seamless integration with third-party applications Simplified development: Provides a clear and concise design framework Scalability: Supports high volumes of requests without compromising performance Detailed Documentation Comprehensive documentation is essential for understanding the capabilities of a REST API. It includes: Endpoint URLs and parameters Request and response formats Error codes and handling Testing REST APIs To ensure proper functioning, REST APIs should be thoroughly tested. This can be done using tools like curl or Postman. However, excessive testing should be avoided to prevent overloading servers. Summary REST APIs are powerful tools for creating web services that can be accessed and integrated by various applications. They offer a wide range of functionalities, including CRUD operations, listing, and specialized functions. Authentication mechanisms ensure data protection and prevent abuse. Formal specifications provide guidance for developers, and detailed documentation simplifies API implementation. By leveraging REST APIs, developers can create interoperable, scalable, and user-friendly systems.","title":"API Data Transfer Format"},{"location":"Week%206/Week%206-53-70/","text":"Week 6-53-70.pdf (PDF file) Summary Introduction to OpenAPI Specification OpenAPI Specification (OAS), formerly known as Swagger, is a vendor-neutral format for describing HTTP-based remote APIs. It aims to provide a standardized way to define the structure, functionality, and semantics of RESTful APIs. OAS enables efficient and automated processing of API information, fostering seamless communication between different applications and systems. Benefits of OpenAPI Specification Information Hiding: OAS decouples the implementation details of the server and client, ensuring that neither party needs to know the specifics of the other's architecture. Unbreakable Contract: OAS serves as a stable and unbreakable contract between the API provider and consumers, preventing unexpected changes that could disrupt communication. Efficient Communication: By providing a standardized description, OAS facilitates automated processing, including boilerplate code generation and mock server creation. Documentation Consistency: OAS provides a machine-readable and structured format for API documentation, eliminating inconsistencies and subjective interpretations. Concepts and Structure of OpenAPI Specification OAS is defined using YAML or JSON and follows a specific structure: OpenAPI Version: Specifies the version of the OAS being used. Info: Provides general information about the API, such as its title, version, and a brief description. Paths: Defines the endpoints exposed by the API, along with their HTTP methods, parameters, request formats, and response formats. Operations: Describes the individual operations supported by each endpoint, including their specific behaviors, input parameters, and output responses. Responses: Specifies the possible HTTP response codes and their associated content types. Schemas: Defines the data structures used in the API, including request and response payloads. Parameters: Describes the parameters that can be passed to the API, including their types, locations (e.g., query string, header), and whether they are required. Request Body: Defines the format and structure of the request payload. Best Practices for OpenAPI Specification Design-First Approach: Begin by designing the API using OAS before implementing the code to ensure consistency and clarity. Single Source of Truth: Maintain the OAS as the authoritative source of truth for the API, with code generation or documentation derivation as needed. Source Code Version Control: Integrate the OAS into the project's version control system to track changes and ensure alignment with the codebase. Openness and Transparency: Encourage public documentation of the OAS to facilitate problem identification and resolution. Leverage Automated Tools: Utilize OpenAPI tools, editors, and code generators to automate tasks and improve productivity. Conclusion OpenAPI Specification is a powerful tool for designing and documenting RESTful APIs, providing a standardized and efficient way to facilitate communication between applications and systems. By embracing OAS best practices, developers can create reliable, well-documented APIs that enhance interoperability and promote collaboration.","title":"Week 6-53-70.pdf (PDF file)"},{"location":"Week%206/Week%206-53-70/#week-6-53-70pdf-pdf-file","text":"Summary Introduction to OpenAPI Specification OpenAPI Specification (OAS), formerly known as Swagger, is a vendor-neutral format for describing HTTP-based remote APIs. It aims to provide a standardized way to define the structure, functionality, and semantics of RESTful APIs. OAS enables efficient and automated processing of API information, fostering seamless communication between different applications and systems. Benefits of OpenAPI Specification Information Hiding: OAS decouples the implementation details of the server and client, ensuring that neither party needs to know the specifics of the other's architecture. Unbreakable Contract: OAS serves as a stable and unbreakable contract between the API provider and consumers, preventing unexpected changes that could disrupt communication. Efficient Communication: By providing a standardized description, OAS facilitates automated processing, including boilerplate code generation and mock server creation. Documentation Consistency: OAS provides a machine-readable and structured format for API documentation, eliminating inconsistencies and subjective interpretations. Concepts and Structure of OpenAPI Specification OAS is defined using YAML or JSON and follows a specific structure: OpenAPI Version: Specifies the version of the OAS being used. Info: Provides general information about the API, such as its title, version, and a brief description. Paths: Defines the endpoints exposed by the API, along with their HTTP methods, parameters, request formats, and response formats. Operations: Describes the individual operations supported by each endpoint, including their specific behaviors, input parameters, and output responses. Responses: Specifies the possible HTTP response codes and their associated content types. Schemas: Defines the data structures used in the API, including request and response payloads. Parameters: Describes the parameters that can be passed to the API, including their types, locations (e.g., query string, header), and whether they are required. Request Body: Defines the format and structure of the request payload. Best Practices for OpenAPI Specification Design-First Approach: Begin by designing the API using OAS before implementing the code to ensure consistency and clarity. Single Source of Truth: Maintain the OAS as the authoritative source of truth for the API, with code generation or documentation derivation as needed. Source Code Version Control: Integrate the OAS into the project's version control system to track changes and ensure alignment with the codebase. Openness and Transparency: Encourage public documentation of the OAS to facilitate problem identification and resolution. Leverage Automated Tools: Utilize OpenAPI tools, editors, and code generators to automate tasks and improve productivity. Conclusion OpenAPI Specification is a powerful tool for designing and documenting RESTful APIs, providing a standardized and efficient way to facilitate communication between applications and systems. By embracing OAS best practices, developers can create reliable, well-documented APIs that enhance interoperability and promote collaboration.","title":"Week 6-53-70.pdf (PDF file)"},{"location":"Week%206/apidesign/","text":"Week 6 Summary REST and APIs API Design Web architecture - REST: REST (REpresentational State Transfer) is a software architecture style for distributed systems on the web. It defines a set of constraints that guide the design of web services. API Examples: APIs (Application Programming Interfaces) are interfaces that allow applications to communicate with each other. Examples of APIs include HTTP, HTTPS, SOAP, and REST. OpenAPI specification: The OpenAPI Specification (OAS) is a language-agnostic specification for describing REST APIs. It provides a common way to document and share APIs. Distributed Software Architecture Servers - Clients: In a distributed software architecture, clients and servers communicate with each other over a network. Standard \u201cprotocols\u201d needed for communication: Protocols are sets of rules that govern how clients and servers communicate with each other. Some common protocols include HTTP, HTTPS, and SOAP. Assumptions? When designing a distributed software architecture, it is important to consider the following assumptions: Is the server always on? Does the server know what the client is doing? Is client authentication required? What is the network latency? The Web Client - Server may be far apart: Clients and servers on the web can be located far apart from each other. Different networks, latencies, quality: Clients and servers can be connected to different networks with different latencies and quality of service. Authentication? Not core part of protocol: Authentication is not a core part of the web protocol. State? Servers do not know the state of the client. Clients cannot be sure of the state of the server. Architecture for the Web Roy Fielding, PhD thesis 2000 UC Irvine: Roy Fielding's PhD thesis, \"Architectural Styles and the Design of Network-based Software Architectures,\" introduced the concept of REST. \u201cREpresentational State Transfer\u201d - REST: REST is an architectural style that takes into account the limitations of the web and provides guidelines for designing web services. Software Architecture Style: REST is a software architecture style, not a set of rules. REST Constraints Constraint 1: Client - Server Network Clients: End users who request data and display it. Servers: Store data and provide it on demand. Network: Connects clients to servers and transmits data. Constraint 2: Stateless Servers cannot assume the state of the client. Clients cannot assume the state of the server. Constraint 3: Layered System Networks, load balancers, proxy frontends, authentication servers, and backends are all components of a layered system. Constraint 4: Cacheability Responses can be cached by proxy caches and browsers to improve performance. Constraint 5: Uniform Interface Clients and servers interact in a uniform and predictable manner. Servers expose resources that can be discovered by clients. Constraint 6: Code on Demand (Optional) Servers can extend client functionality by providing code (e.g., JavaScript, Java applets).","title":"Week 6"},{"location":"Week%206/apidesign/#week-6","text":"Summary","title":"Week 6"},{"location":"Week%206/apidesign/#rest-and-apis","text":"","title":"REST and APIs"},{"location":"Week%206/apidesign/#api-design","text":"Web architecture - REST: REST (REpresentational State Transfer) is a software architecture style for distributed systems on the web. It defines a set of constraints that guide the design of web services. API Examples: APIs (Application Programming Interfaces) are interfaces that allow applications to communicate with each other. Examples of APIs include HTTP, HTTPS, SOAP, and REST. OpenAPI specification: The OpenAPI Specification (OAS) is a language-agnostic specification for describing REST APIs. It provides a common way to document and share APIs.","title":"API Design"},{"location":"Week%206/apidesign/#distributed-software-architecture","text":"Servers - Clients: In a distributed software architecture, clients and servers communicate with each other over a network. Standard \u201cprotocols\u201d needed for communication: Protocols are sets of rules that govern how clients and servers communicate with each other. Some common protocols include HTTP, HTTPS, and SOAP. Assumptions? When designing a distributed software architecture, it is important to consider the following assumptions: Is the server always on? Does the server know what the client is doing? Is client authentication required? What is the network latency?","title":"Distributed Software Architecture"},{"location":"Week%206/apidesign/#the-web","text":"Client - Server may be far apart: Clients and servers on the web can be located far apart from each other. Different networks, latencies, quality: Clients and servers can be connected to different networks with different latencies and quality of service. Authentication? Not core part of protocol: Authentication is not a core part of the web protocol. State? Servers do not know the state of the client. Clients cannot be sure of the state of the server.","title":"The Web"},{"location":"Week%206/apidesign/#architecture-for-the-web","text":"Roy Fielding, PhD thesis 2000 UC Irvine: Roy Fielding's PhD thesis, \"Architectural Styles and the Design of Network-based Software Architectures,\" introduced the concept of REST. \u201cREpresentational State Transfer\u201d - REST: REST is an architectural style that takes into account the limitations of the web and provides guidelines for designing web services. Software Architecture Style: REST is a software architecture style, not a set of rules.","title":"Architecture for the Web"},{"location":"Week%206/apidesign/#rest-constraints","text":"Constraint 1: Client - Server Network Clients: End users who request data and display it. Servers: Store data and provide it on demand. Network: Connects clients to servers and transmits data. Constraint 2: Stateless Servers cannot assume the state of the client. Clients cannot assume the state of the server. Constraint 3: Layered System Networks, load balancers, proxy frontends, authentication servers, and backends are all components of a layered system. Constraint 4: Cacheability Responses can be cached by proxy caches and browsers to improve performance. Constraint 5: Uniform Interface Clients and servers interact in a uniform and predictable manner. Servers expose resources that can be discovered by clients. Constraint 6: Code on Demand (Optional) Servers can extend client functionality by providing code (e.g., JavaScript, Java applets).","title":"REST Constraints"},{"location":"Week%206/openapi/","text":"OpenAPI, formerly known as Swagger, is a specification for building APIs. It provides a standard way to describe the structure of your APIs so that machines can read them. Here\u2019s a summary of the key components and features of OpenAPI: Key Components OpenAPI Specification (OAS) : A standard, language-agnostic interface to RESTful APIs. Allows both humans and computers to discover and understand the capabilities of a service without access to source code, documentation, or network traffic inspection. Paths : Define the endpoints (resources) and the operations on each endpoint. Each path can have multiple operations (e.g., GET, POST, PUT, DELETE). Operations : Describe the HTTP methods used to interact with the API. Include details like parameters, request bodies, responses, and security requirements. Parameters : Define the inputs to the API operations. Can be in the path, query string, headers, or cookies. Request Body : Describes the payload sent with POST, PUT, and PATCH requests. Can include schema definitions for complex data structures. Responses : Define the possible responses from an API operation. Include status codes, headers, and response bodies. Schemas : Define the structure of the request and response bodies. Use JSON Schema to describe the data models. Security : Define the security mechanisms (e.g., API keys, OAuth2) used to protect the API. Can be applied globally or to specific operations. Tags : Organize operations into groups for better readability and management. External Documentation : Provide links to additional documentation or resources. Features Documentation : Automatically generate interactive API documentation (e.g., Swagger UI). Allows developers to explore and test API endpoints directly from the documentation. Code Generation : Generate client libraries, server stubs, and API documentation in various programming languages. Tools like Swagger Codegen and OpenAPI Generator support this feature. Validation : Validate API requests and responses against the OpenAPI specification. Ensure that the API adheres to the defined contract. Interoperability : Standardized format allows for easy integration with other tools and services. Supports a wide range of tools for API design, testing, and monitoring. Example Here\u2019s a simple example of an OpenAPI specification in YAML format: openapi : 3.0.0 info : title : Simple API version : 1.0.0 paths : /users : get : summary : List all users responses : '200' : description : A list of users content : application/json : schema : type : array items : type : object properties : id : type : integer name : type : string This example defines a simple API with one endpoint ( /users ) that supports a GET operation to list all users. Conclusion OpenAPI is a powerful tool for designing, documenting, and interacting with APIs. It standardizes the way APIs are described, making it easier for developers to understand and use them. By leveraging OpenAPI, you can improve the consistency, quality, and usability of your APIs.","title":"Openapi"},{"location":"Week%206/openapi/#key-components","text":"OpenAPI Specification (OAS) : A standard, language-agnostic interface to RESTful APIs. Allows both humans and computers to discover and understand the capabilities of a service without access to source code, documentation, or network traffic inspection. Paths : Define the endpoints (resources) and the operations on each endpoint. Each path can have multiple operations (e.g., GET, POST, PUT, DELETE). Operations : Describe the HTTP methods used to interact with the API. Include details like parameters, request bodies, responses, and security requirements. Parameters : Define the inputs to the API operations. Can be in the path, query string, headers, or cookies. Request Body : Describes the payload sent with POST, PUT, and PATCH requests. Can include schema definitions for complex data structures. Responses : Define the possible responses from an API operation. Include status codes, headers, and response bodies. Schemas : Define the structure of the request and response bodies. Use JSON Schema to describe the data models. Security : Define the security mechanisms (e.g., API keys, OAuth2) used to protect the API. Can be applied globally or to specific operations. Tags : Organize operations into groups for better readability and management. External Documentation : Provide links to additional documentation or resources.","title":"Key Components"},{"location":"Week%206/openapi/#features","text":"Documentation : Automatically generate interactive API documentation (e.g., Swagger UI). Allows developers to explore and test API endpoints directly from the documentation. Code Generation : Generate client libraries, server stubs, and API documentation in various programming languages. Tools like Swagger Codegen and OpenAPI Generator support this feature. Validation : Validate API requests and responses against the OpenAPI specification. Ensure that the API adheres to the defined contract. Interoperability : Standardized format allows for easy integration with other tools and services. Supports a wide range of tools for API design, testing, and monitoring.","title":"Features"},{"location":"Week%206/openapi/#example","text":"Here\u2019s a simple example of an OpenAPI specification in YAML format: openapi : 3.0.0 info : title : Simple API version : 1.0.0 paths : /users : get : summary : List all users responses : '200' : description : A list of users content : application/json : schema : type : array items : type : object properties : id : type : integer name : type : string This example defines a simple API with one endpoint ( /users ) that supports a GET operation to list all users.","title":"Example"},{"location":"Week%206/openapi/#conclusion","text":"OpenAPI is a powerful tool for designing, documenting, and interacting with APIs. It standardizes the way APIs are described, making it easier for developers to understand and use them. By leveraging OpenAPI, you can improve the consistency, quality, and usability of your APIs.","title":"Conclusion"},{"location":"arifacts/1/","text":"","title":"1"},{"location":"arifacts/viva/","text":"viva.pdf (PDF file) Summary db.Model vs db.Table: db.Model: For data models with associated methods. db.Table: For table structures without additional features. HTTP Methods: GET: Retrieve a resource. POST: Create a new resource. PUT: Update an existing resource. DELETE: Remove a resource. PATCH: Update a portion of a resource. MVC Architecture: Model: Handles data and logic. View: Displays data to the user. Controller: Manages user input and updates the Model and View. Relationships in Databases: Define how data in different tables is related. Types: One-to-One, One-to-Many, Many-to-Many. Normalization: Organizes data to reduce redundancy and dependence. Levels: First, Second, Third. ACID vs BASE: ACID: Guarantees transactions are atomic, consistent, isolated, and durable. BASE: Emphasizes availability, soft state, and eventual consistency. Primary Key and Unique Key: Primary Key: Uniquely identifies each record in a table and cannot contain null values. Unique Key: Ensures uniqueness but allows one null value. Exception Handling: try: Contains code that may raise an exception. except: Catches and handles specific exceptions. finally: Code that will execute regardless of whether an exception occurred. Error Handler: Used to handle errors in a web application. Maps specific HTTP status codes to appropriate error messages and actions. Cluster: A method of organizing or storing data to improve performance. Types: Index clusters (optimize query performance) and table clusters (store related data together). Authentication vs Authorization: Authentication: Verifying the identity of a user or system. Authorization: Determining what actions or resources an authenticated entity can access. Cell Padding and Cell Spacing: Cell Padding: Space between text and cell itself. Cell Spacing: Space between cells. Rest API and its Methods: RESTful API: An architectural style for designing networked applications. Methods: GET (fetch data), POST (submit data), PUT (update/create data), DELETE (remove data), PATCH (make a small update) SQLAlchemy: A Python library that simplifies database interactions using an Object-Relational Mapping (ORM) system. Provides classes that mirror database tables, making database operations more Pythonic. ORM: Object-Relational Mapping allows you to interact with a database using objects in your programming language. Simplifies database interactions by representing tables as classes and rows as instances of those classes. Controller Sends and Receives API: The controller in a web application handles HTTP requests and sends and receives API data. Requests are processed, and appropriate responses are sent using libraries like 'requests'. The controller interacts with databases and business logic to handle API interactions. @app.route(): A Flask decorator used to associate a function with a URL route. Informs Flask which function to execute when a particular URL is accessed. Template Inheritance: Allows you to create a base or parent template with a common structure. Other templates can then inherit from this base template and customize specific content sections. Lazy Loading: A technique where resources or data are loaded only when needed, improving the initial page load time. Commonly used with images, scripts, or other assets on a webpage. Single Page Application (SPA): A web application where the initial page load contains all necessary content, and subsequent interactions dynamically update the page without requiring full page reloads. Provides a more responsive and interactive user experience. Flask: A lightweight and flexible web framework for Python. Provides a simple and extensible platform for building web applications. 2-Tier vs 3-Tier Architecture: 2-Tier: Client-server model with direct communication between client and server. 3-Tier: Introduces an application layer between client and server, providing an additional layer of business logic and improved scalability. Static vs Dynamic Pages: Static Pages: Content is pre-generated and remains unchanged unless manually modified. Dynamic Pages: Content is generated on-demand based on user interactions or data from databases. Types of Testing: Unit Testing: Testing individual components of software. White Box Testing: Examining the internal structure of software. Black Box Testing: Testing software functionality without knowing its internal code. Integrated Testing: Verifying interactions between integrated components or systems. List vs Tuple vs Dictionary: List: Mutable sequence of elements. Tuple: Immutable sequence of elements. Dictionary: Collection of key-value pairs. Primary Keys: Unique identifiers assigned to each record in a table. Ensure data integrity, efficient data retrieval, and relationships between tables. Bootstrap: A front-end framework providing pre-designed and reusable components for creating visually appealing and mobile-friendly user interfaces. Indexing: A technique that enhances the speed of data retrieval operations by creating data structures (indexes) to quickly locate and access specific records. Git: A distributed version control system that enables collaboration, history tracking, and version control in software development. Built-in HTML5 Form Controls: Provide partial validation, such as required fields, minimum or maximum values, and custom patterns. Sandboxing: A secure area provided by JavaScript engines to run code without accessing local files or network resources. Lec file viva.pdf (PDF file)","title":"viva.pdf (PDF file)"},{"location":"arifacts/viva/#vivapdf-pdf-file","text":"Summary db.Model vs db.Table: db.Model: For data models with associated methods. db.Table: For table structures without additional features. HTTP Methods: GET: Retrieve a resource. POST: Create a new resource. PUT: Update an existing resource. DELETE: Remove a resource. PATCH: Update a portion of a resource. MVC Architecture: Model: Handles data and logic. View: Displays data to the user. Controller: Manages user input and updates the Model and View. Relationships in Databases: Define how data in different tables is related. Types: One-to-One, One-to-Many, Many-to-Many. Normalization: Organizes data to reduce redundancy and dependence. Levels: First, Second, Third. ACID vs BASE: ACID: Guarantees transactions are atomic, consistent, isolated, and durable. BASE: Emphasizes availability, soft state, and eventual consistency. Primary Key and Unique Key: Primary Key: Uniquely identifies each record in a table and cannot contain null values. Unique Key: Ensures uniqueness but allows one null value. Exception Handling: try: Contains code that may raise an exception. except: Catches and handles specific exceptions. finally: Code that will execute regardless of whether an exception occurred. Error Handler: Used to handle errors in a web application. Maps specific HTTP status codes to appropriate error messages and actions. Cluster: A method of organizing or storing data to improve performance. Types: Index clusters (optimize query performance) and table clusters (store related data together). Authentication vs Authorization: Authentication: Verifying the identity of a user or system. Authorization: Determining what actions or resources an authenticated entity can access. Cell Padding and Cell Spacing: Cell Padding: Space between text and cell itself. Cell Spacing: Space between cells. Rest API and its Methods: RESTful API: An architectural style for designing networked applications. Methods: GET (fetch data), POST (submit data), PUT (update/create data), DELETE (remove data), PATCH (make a small update) SQLAlchemy: A Python library that simplifies database interactions using an Object-Relational Mapping (ORM) system. Provides classes that mirror database tables, making database operations more Pythonic. ORM: Object-Relational Mapping allows you to interact with a database using objects in your programming language. Simplifies database interactions by representing tables as classes and rows as instances of those classes. Controller Sends and Receives API: The controller in a web application handles HTTP requests and sends and receives API data. Requests are processed, and appropriate responses are sent using libraries like 'requests'. The controller interacts with databases and business logic to handle API interactions. @app.route(): A Flask decorator used to associate a function with a URL route. Informs Flask which function to execute when a particular URL is accessed. Template Inheritance: Allows you to create a base or parent template with a common structure. Other templates can then inherit from this base template and customize specific content sections. Lazy Loading: A technique where resources or data are loaded only when needed, improving the initial page load time. Commonly used with images, scripts, or other assets on a webpage. Single Page Application (SPA): A web application where the initial page load contains all necessary content, and subsequent interactions dynamically update the page without requiring full page reloads. Provides a more responsive and interactive user experience. Flask: A lightweight and flexible web framework for Python. Provides a simple and extensible platform for building web applications. 2-Tier vs 3-Tier Architecture: 2-Tier: Client-server model with direct communication between client and server. 3-Tier: Introduces an application layer between client and server, providing an additional layer of business logic and improved scalability. Static vs Dynamic Pages: Static Pages: Content is pre-generated and remains unchanged unless manually modified. Dynamic Pages: Content is generated on-demand based on user interactions or data from databases. Types of Testing: Unit Testing: Testing individual components of software. White Box Testing: Examining the internal structure of software. Black Box Testing: Testing software functionality without knowing its internal code. Integrated Testing: Verifying interactions between integrated components or systems. List vs Tuple vs Dictionary: List: Mutable sequence of elements. Tuple: Immutable sequence of elements. Dictionary: Collection of key-value pairs. Primary Keys: Unique identifiers assigned to each record in a table. Ensure data integrity, efficient data retrieval, and relationships between tables. Bootstrap: A front-end framework providing pre-designed and reusable components for creating visually appealing and mobile-friendly user interfaces. Indexing: A technique that enhances the speed of data retrieval operations by creating data structures (indexes) to quickly locate and access specific records. Git: A distributed version control system that enables collaboration, history tracking, and version control in software development. Built-in HTML5 Form Controls: Provide partial validation, such as required fields, minimum or maximum values, and custom patterns. Sandboxing: A secure area provided by JavaScript engines to run code without accessing local files or network resources. Lec file","title":"viva.pdf (PDF file)"},{"location":"arifacts/viva/#vivapdf-pdf-file_1","text":"","title":"viva.pdf (PDF file)"},{"location":"reference/embeding/","text":"","title":"Embeding"},{"location":"week%205/crud/","text":"CRUD Summary CRUD Operations CRUD (Create-Read-Update-Delete) is a fundamental concept in database operations. It encompasses the essential operations performed on data: Create: Adds a new entry to the database. Ensures that the entry does not already exist. Checks within the database to avoid conflicts. Considers mandatory and optional fields. Read: Retrieves data from the database. Can involve summarizing data, such as counts, distributions, or histograms. Update: Modifies existing data in the database. Can involve changing values, addresses, or dates. Delete: Removes data from the database. Can be used to remove completed records or correct errors. API (Application Programming Interface) An API provides a standardized method for interacting with a server. It allows clients to access server functionality without knowing the underlying implementation. CRUD operations form a basic set of functionality for many APIs, particularly in the context of web applications. Controllers Controllers group related actions logically. Actions represent specific operations, while controllers organize those actions into meaningful categories. This separation allows for flexible and maintainable code. Separation of Concerns MVC (Model-View-Controller) is a design pattern that promotes the separation of concerns between different components of an application: Models: Represent the data and its behavior. Views: Display the data to users. Controllers: Process user input and interact with models. This separation allows for flexibility and maintainability, as different components can be modified independently. Rules of Thumb Views and controllers should be independent of the model. Controllers should not directly interact with databases. In practice, views and controllers often have close interdependencies. HTTP Verbs HTTP verbs convey different meanings in API interactions: GET: Retrieve data POST: Create new data PUT: Update existing data DELETE: Remove data Understanding these concepts is crucial for designing and implementing efficient and user-friendly web applications. usage of the \"enctype\" attribute in HTML forms: The \"enctype\" attribute can be used with HTML form elements regardless of the request method (GET or POST). However, its practical application and effect are most relevant when the form method is POST. Here's a more detailed explanation: Usage with POST method: When the form method is POST, the \"enctype\" attribute specifies how the form data should be encoded before sending it to the server. There are three possible values for \"enctype\" with POST: a) application/x-www-form-urlencoded (default) b) multipart/form-data c) text/plain The \"multipart/form-data\" encoding is particularly important when uploading files through a form. 2. Usage with GET method: When the form method is GET, the \"enctype\" attribute is generally ignored by browsers. This is because GET requests send data as part of the URL query string, which has its own encoding rules. So, while you can technically include the \"enctype\" attribute in a form with method=\"GET\", it won't have any practical effect on how the data is sent. Here's an example of a form using POST method with \"enctype\" specified: < form action = \"/upload\" method = \"POST\" enctype = \"multipart/form-data\" > < input type = \"file\" name = \"fileUpload\" > < input type = \"submit\" value = \"Upload\" > </ form > In this case, the \"enctype\" attribute is crucial for proper file uploading. To summarize, while the \"enctype\" attribute is most relevant and commonly used with POST requests, it's not strictly limited to POST methods in terms of HTML syntax. It's just that its effect is only meaningful with POST requests. You're correct to highlight \"application/x-www-form-urlencoded\" as the default encoding type for HTML forms.its usage: Default Behavior: When you don't specify an \"enctype\" attribute in your form, the browser automatically uses \"application/x-www-form-urlencoded\". This means you don't need to explicitly set it unless you want to use a different encoding type. Format: With this encoding, form data is sent as name-value pairs. Each name-value pair is separated by an ampersand (&), and spaces are replaced by plus signs (+). Special characters are percent-encoded. Example: If you have a form with fields \"name\" and \"age\", the encoded data might look like this: name=John+Doe&age=30 4. Usage: This encoding is suitable for most forms that don't involve file uploads. It's efficient for sending text data. 5. Code Example: Here's how you would explicitly set this encoding (though it's not necessary as it's the default): < form action = \"/submit\" method = \"POST\" enctype = \"application/x-www-form-urlencoded\" > < input type = \"text\" name = \"username\" > < input type = \"password\" name = \"password\" > < input type = \"submit\" value = \"Login\" > </ form > 6. Limitations: While this encoding works well for most text data, it's not suitable for sending large amounts of data or for file uploads. In those cases, \"multipart/form-data\" is more appropriate. 7. GET vs POST: When using the GET method, form data is automatically encoded in the URL using this format, regardless of the \"enctype\" attribute. 8. Server-side Handling: Most server-side frameworks and languages have built-in support for parsing \"application/x-www-form-urlencoded\" data, making it easy to work with on the backend. Understanding this default encoding type is crucial for web developers, as it affects how data is sent to the server and how it needs to be processed on the server side. It's particularly important when debugging form submissions or when working with APIs that expect data in this format.","title":"CRUD"},{"location":"week%205/crud/#crud","text":"Summary CRUD Operations CRUD (Create-Read-Update-Delete) is a fundamental concept in database operations. It encompasses the essential operations performed on data: Create: Adds a new entry to the database. Ensures that the entry does not already exist. Checks within the database to avoid conflicts. Considers mandatory and optional fields. Read: Retrieves data from the database. Can involve summarizing data, such as counts, distributions, or histograms. Update: Modifies existing data in the database. Can involve changing values, addresses, or dates. Delete: Removes data from the database. Can be used to remove completed records or correct errors. API (Application Programming Interface) An API provides a standardized method for interacting with a server. It allows clients to access server functionality without knowing the underlying implementation. CRUD operations form a basic set of functionality for many APIs, particularly in the context of web applications. Controllers Controllers group related actions logically. Actions represent specific operations, while controllers organize those actions into meaningful categories. This separation allows for flexible and maintainable code. Separation of Concerns MVC (Model-View-Controller) is a design pattern that promotes the separation of concerns between different components of an application: Models: Represent the data and its behavior. Views: Display the data to users. Controllers: Process user input and interact with models. This separation allows for flexibility and maintainability, as different components can be modified independently. Rules of Thumb Views and controllers should be independent of the model. Controllers should not directly interact with databases. In practice, views and controllers often have close interdependencies. HTTP Verbs HTTP verbs convey different meanings in API interactions: GET: Retrieve data POST: Create new data PUT: Update existing data DELETE: Remove data Understanding these concepts is crucial for designing and implementing efficient and user-friendly web applications. usage of the \"enctype\" attribute in HTML forms: The \"enctype\" attribute can be used with HTML form elements regardless of the request method (GET or POST). However, its practical application and effect are most relevant when the form method is POST. Here's a more detailed explanation: Usage with POST method: When the form method is POST, the \"enctype\" attribute specifies how the form data should be encoded before sending it to the server. There are three possible values for \"enctype\" with POST: a) application/x-www-form-urlencoded (default) b) multipart/form-data c) text/plain The \"multipart/form-data\" encoding is particularly important when uploading files through a form. 2. Usage with GET method: When the form method is GET, the \"enctype\" attribute is generally ignored by browsers. This is because GET requests send data as part of the URL query string, which has its own encoding rules. So, while you can technically include the \"enctype\" attribute in a form with method=\"GET\", it won't have any practical effect on how the data is sent. Here's an example of a form using POST method with \"enctype\" specified: < form action = \"/upload\" method = \"POST\" enctype = \"multipart/form-data\" > < input type = \"file\" name = \"fileUpload\" > < input type = \"submit\" value = \"Upload\" > </ form > In this case, the \"enctype\" attribute is crucial for proper file uploading. To summarize, while the \"enctype\" attribute is most relevant and commonly used with POST requests, it's not strictly limited to POST methods in terms of HTML syntax. It's just that its effect is only meaningful with POST requests. You're correct to highlight \"application/x-www-form-urlencoded\" as the default encoding type for HTML forms.its usage: Default Behavior: When you don't specify an \"enctype\" attribute in your form, the browser automatically uses \"application/x-www-form-urlencoded\". This means you don't need to explicitly set it unless you want to use a different encoding type. Format: With this encoding, form data is sent as name-value pairs. Each name-value pair is separated by an ampersand (&), and spaces are replaced by plus signs (+). Special characters are percent-encoded. Example: If you have a form with fields \"name\" and \"age\", the encoded data might look like this: name=John+Doe&age=30 4. Usage: This encoding is suitable for most forms that don't involve file uploads. It's efficient for sending text data. 5. Code Example: Here's how you would explicitly set this encoding (though it's not necessary as it's the default): < form action = \"/submit\" method = \"POST\" enctype = \"application/x-www-form-urlencoded\" > < input type = \"text\" name = \"username\" > < input type = \"password\" name = \"password\" > < input type = \"submit\" value = \"Login\" > </ form > 6. Limitations: While this encoding works well for most text data, it's not suitable for sending large amounts of data or for file uploads. In those cases, \"multipart/form-data\" is more appropriate. 7. GET vs POST: When using the GET method, form data is automatically encoded in the URL using this format, regardless of the \"enctype\" attribute. 8. Server-side Handling: Most server-side frameworks and languages have built-in support for parsing \"application/x-www-form-urlencoded\" data, making it easy to work with on the backend. Understanding this default encoding type is crucial for web developers, as it affects how data is sent to the server and how it needs to be processed on the server side. It's particularly important when debugging form submissions or when working with APIs that expect data in this format.","title":"CRUD"},{"location":"week%205/mvc/","text":"MVC Summary Controllers Controllers in the context of web development play a crucial role in handling user input and determining the appropriate responses. They act as intermediaries between the user interface (view) and the data model, facilitating the flow of information and orchestrating the application's logic. Origins of MVC The concept of MVC (Model-View-Controller) originated in the realm of graphical user interfaces (GUIs). It emerged as a design pattern aiming to separate the different concerns of an application, namely the data model, the user interface, and the logic that connects them. Request-Response Cycle in Web Applications In the context of web applications, interactions between the client (user) and the server occur through a series of requests and responses. When a user interacts with a web page, such as clicking a link or submitting a form, the browser sends a request to the server. The server then processes the request, generates a response, and sends it back to the browser. This response typically contains the updated content or a new page to be displayed to the user. Grouping Actions: Controllers Controllers in web applications are responsible for handling specific actions or tasks. They receive requests from the user, process them, and determine the appropriate responses. For instance, in a gradebook application, the controller might handle actions such as adding a new student, assigning a student to a course, or updating a student's marks. CRUD Operations CRUD (Create, Read, Update, Delete) operations are fundamental to many web applications. They represent the basic operations that can be performed on data stored in a database. Controllers often encapsulate these operations, providing methods for creating, retrieving, updating, and deleting data. Routes and Controllers Routes are patterns that define how incoming requests are mapped to specific controllers and actions. When a user accesses a particular URL, the web framework matches the URL to a predefined route and invokes the corresponding controller and action. This mechanism allows for a clean and organized way of handling different types of requests. Applicability of MVC in Web Development While MVC was initially conceived for GUI applications, it has also been adapted to the context of web development. However, certain aspects of MVC may not translate directly to the web due to differences in the nature of web applications. For instance, web applications often do not maintain the state of individual clients, and the separation between the view and the model may not be as distinct as in traditional GUI applications. Separation of Concerns Despite these differences, MVC remains a valuable conceptual framework for understanding the separation of concerns in web applications. By separating the data model, view, and controller, MVC promotes code organization and maintainability. It allows developers to focus on specific aspects of the application without getting entangled in the complexities of other components. Basic Learnings from MVC The basic principles of MVC can be applied to web development, including: Separation of concerns into model, view, and controller Use of controllers to handle user input and determine responses Use of routes to map requests to specific controllers and actions Application of CRUD operations to manage data Flexibility and Adaptability It is important to note that MVC should not be applied rigidly in web development. The specific implementation of MVC may vary depending on the application and framework being used. Developers should be prepared to adapt and extend the basic concepts of MVC to fit the unique requirements of their web applications.","title":"MVC"},{"location":"week%205/mvc/#mvc","text":"Summary Controllers Controllers in the context of web development play a crucial role in handling user input and determining the appropriate responses. They act as intermediaries between the user interface (view) and the data model, facilitating the flow of information and orchestrating the application's logic. Origins of MVC The concept of MVC (Model-View-Controller) originated in the realm of graphical user interfaces (GUIs). It emerged as a design pattern aiming to separate the different concerns of an application, namely the data model, the user interface, and the logic that connects them. Request-Response Cycle in Web Applications In the context of web applications, interactions between the client (user) and the server occur through a series of requests and responses. When a user interacts with a web page, such as clicking a link or submitting a form, the browser sends a request to the server. The server then processes the request, generates a response, and sends it back to the browser. This response typically contains the updated content or a new page to be displayed to the user. Grouping Actions: Controllers Controllers in web applications are responsible for handling specific actions or tasks. They receive requests from the user, process them, and determine the appropriate responses. For instance, in a gradebook application, the controller might handle actions such as adding a new student, assigning a student to a course, or updating a student's marks. CRUD Operations CRUD (Create, Read, Update, Delete) operations are fundamental to many web applications. They represent the basic operations that can be performed on data stored in a database. Controllers often encapsulate these operations, providing methods for creating, retrieving, updating, and deleting data. Routes and Controllers Routes are patterns that define how incoming requests are mapped to specific controllers and actions. When a user accesses a particular URL, the web framework matches the URL to a predefined route and invokes the corresponding controller and action. This mechanism allows for a clean and organized way of handling different types of requests. Applicability of MVC in Web Development While MVC was initially conceived for GUI applications, it has also been adapted to the context of web development. However, certain aspects of MVC may not translate directly to the web due to differences in the nature of web applications. For instance, web applications often do not maintain the state of individual clients, and the separation between the view and the model may not be as distinct as in traditional GUI applications. Separation of Concerns Despite these differences, MVC remains a valuable conceptual framework for understanding the separation of concerns in web applications. By separating the data model, view, and controller, MVC promotes code organization and maintainability. It allows developers to focus on specific aspects of the application without getting entangled in the complexities of other components. Basic Learnings from MVC The basic principles of MVC can be applied to web development, including: Separation of concerns into model, view, and controller Use of controllers to handle user input and determine responses Use of routes to map requests to specific controllers and actions Application of CRUD operations to manage data Flexibility and Adaptability It is important to note that MVC should not be applied rigidly in web development. The specific implementation of MVC may vary depending on the application and framework being used. Developers should be prepared to adapt and extend the basic concepts of MVC to fit the unique requirements of their web applications.","title":"MVC"},{"location":"week%205/route/","text":"Routes Summary Web Applications: A Client-Server Model Web applications operate on the fundamental principle of the client-server model, a paradigm where two distinct entities, the client and the server, collaborate to deliver and execute web-based functionalities. The client, typically a web browser, acts as the interface through which users interact with the web application, sending requests and receiving responses. On the other hand, the server, usually a remote computer, processes the client's requests, retrieves or generates the necessary data, and sends back responses to the client. This back-and-forth communication between the client and the server forms the backbone of web application interactions. Stateless Nature of Web Applications Web applications are inherently stateless, meaning that the server maintains no persistent knowledge or context about the client's previous requests or interactions. Each request is treated as an independent entity, devoid of any awareness of the client's history or state. This characteristic stems from the underlying HTTP protocol, which governs the communication between the client and the server, and is a fundamental design principle of web applications. To accommodate this stateless nature, web applications must be designed to respond to any client request without making assumptions about the client's state. Every request must contain all the necessary information for the server to process it effectively, ensuring that the server can handle each request independently. HTTP Protocol and Routing HTTP (Hypertext Transfer Protocol) serves as the primary communication protocol in web applications. It defines a set of request methods, known as HTTP verbs, such as GET, POST, PUT, DELETE, and others, each conveying a specific meaning or action. These verbs indicate the intended operation on the server-side, allowing the server to interpret the client's request and perform the appropriate actions. In addition to HTTP verbs, URLs (Uniform Resource Locators) play a crucial role in web applications. URLs provide a structured way to identify and locate resources on the server, such as web pages, images, or data. The server uses the URL to determine the specific resource requested by the client. Routing is a fundamental aspect of web applications, and it refers to the process of mapping incoming URLs to specific actions or functions on the server-side. This mapping enables the server to identify the appropriate code to execute based on the URL requested by the client. Routing plays a critical role in directing the flow of the application and determining the appropriate response to each client request. Python Decorators and Function Enhancements Python decorators offer a powerful mechanism to enhance and modify the behavior of functions without altering their original source code. They are prefixed with the \"@\" symbol and are placed above the function definition. Decorators essentially act as functions that take another function as an argument and return a new function that incorporates the added functionality. Decorators provide a flexible way to add pre- or post-processing logic to functions, extending their capabilities without the need for invasive code modifications. They enable developers to modify function behavior dynamically, inject additional functionality, or perform common tasks in a reusable and maintainable manner. Basic Routing in Flask Flask, a popular Python web framework, simplifies the process of routing URLs to specific functions within the application. The @app.route decorator is used to associate a URL with a particular function. When a client makes a request to the specified URL, Flask invokes the corresponding function, allowing the developer to handle the request and generate an appropriate response. For example, the following code defines a simple route in Flask that returns the string \"Hello World!\" when a client accesses the root URL (\"/\"): from flask import Flask app = Flask(__name__) @app.route(\"/\") def home(): return \"Hello World!\" HTTP Verbs and Request Methods HTTP verbs, as mentioned earlier, play a significant role in routing and specifying the intended action on the server-side. Flask allows developers to specify the HTTP methods (GET, POST, PUT, DELETE, etc.) that a particular route supports. This enables finer control over the types of requests that can be handled by a specific route. For instance, the following code defines two routes in Flask: one for handling GET requests to the root URL (\"/\") and another for handling POST requests to the \"/create\" URL: from flask import Flask app = Flask(__name__) @app.route('/', methods=['GET']) def index(): ... @app.route('/create', methods=['POST']) def store(): ... By specifying the allowed HTTP methods, Flask ensures that the appropriate function is invoked based on the method used in the client's request, providing greater flexibility and control over request handling. CRUD-Like Functionality with Flask CRUD (Create, Read, Update, Delete) operations form the foundation of data manipulation in web applications. Flask provides a convenient way to implement CRUD-like functionality by combining routes and HTTP methods. The following code demonstrates how to implement CRUD-like functionality in Flask using decorators: from flask import Flask app = Flask(__name__) # Assume 'index', 'store' etc are functions @app.route('/', methods=['GET'])(index) @app.route('/create', methods=['POST'])(store) @app.route('/<int:user_id>', methods=['GET'])(show) @app.route('/<int:user_id>/edit', methods=['POST'])(update) @app.route('/<int:user_id>', methods=['DELETE'])(destroy) In this code, each decorator associates a specific HTTP method with a URL pattern and the corresponding function. For instance, the @app.route('/create', methods=['POST']) decorator maps the POST method to the \"/create\" URL and invokes the store function when a POST request is made to that URL. Similarly, other decorators handle GET, PUT, and DELETE requests for different URLs, providing a structured and consistent approach to CRUD operations. Summary and Key Concepts Flask, a widely used Python web framework, simplifies the development of web applications by providing a straightforward routing mechanism and support for various HTTP methods. It does not strictly adhere to the Model-View-Controller (MVC) architectural pattern, but it encourages a separation of concerns and clean design practices. Routing in Flask involves mapping URLs to specific functions or actions on the server-side. This enables the application to handle incoming requests and generate appropriate responses based on the requested URL. HTTP verbs play a crucial role in routing, indicating the intended action (e.g., GET, POST, PUT, DELETE). Flask decorators offer a convenient way to enhance function behavior and implement common patterns, such as CRUD-like functionality. They allow developers to add pre- or post-processing logic, inject additional functionality, or perform common tasks in a reusable and maintainable manner. By understanding these concepts and utilizing the tools provided by Flask, developers can create robust and efficient web applications that handle user requests effectively and provide a seamless user experience.","title":"Routes"},{"location":"week%205/route/#routes","text":"Summary Web Applications: A Client-Server Model Web applications operate on the fundamental principle of the client-server model, a paradigm where two distinct entities, the client and the server, collaborate to deliver and execute web-based functionalities. The client, typically a web browser, acts as the interface through which users interact with the web application, sending requests and receiving responses. On the other hand, the server, usually a remote computer, processes the client's requests, retrieves or generates the necessary data, and sends back responses to the client. This back-and-forth communication between the client and the server forms the backbone of web application interactions. Stateless Nature of Web Applications Web applications are inherently stateless, meaning that the server maintains no persistent knowledge or context about the client's previous requests or interactions. Each request is treated as an independent entity, devoid of any awareness of the client's history or state. This characteristic stems from the underlying HTTP protocol, which governs the communication between the client and the server, and is a fundamental design principle of web applications. To accommodate this stateless nature, web applications must be designed to respond to any client request without making assumptions about the client's state. Every request must contain all the necessary information for the server to process it effectively, ensuring that the server can handle each request independently. HTTP Protocol and Routing HTTP (Hypertext Transfer Protocol) serves as the primary communication protocol in web applications. It defines a set of request methods, known as HTTP verbs, such as GET, POST, PUT, DELETE, and others, each conveying a specific meaning or action. These verbs indicate the intended operation on the server-side, allowing the server to interpret the client's request and perform the appropriate actions. In addition to HTTP verbs, URLs (Uniform Resource Locators) play a crucial role in web applications. URLs provide a structured way to identify and locate resources on the server, such as web pages, images, or data. The server uses the URL to determine the specific resource requested by the client. Routing is a fundamental aspect of web applications, and it refers to the process of mapping incoming URLs to specific actions or functions on the server-side. This mapping enables the server to identify the appropriate code to execute based on the URL requested by the client. Routing plays a critical role in directing the flow of the application and determining the appropriate response to each client request. Python Decorators and Function Enhancements Python decorators offer a powerful mechanism to enhance and modify the behavior of functions without altering their original source code. They are prefixed with the \"@\" symbol and are placed above the function definition. Decorators essentially act as functions that take another function as an argument and return a new function that incorporates the added functionality. Decorators provide a flexible way to add pre- or post-processing logic to functions, extending their capabilities without the need for invasive code modifications. They enable developers to modify function behavior dynamically, inject additional functionality, or perform common tasks in a reusable and maintainable manner. Basic Routing in Flask Flask, a popular Python web framework, simplifies the process of routing URLs to specific functions within the application. The @app.route decorator is used to associate a URL with a particular function. When a client makes a request to the specified URL, Flask invokes the corresponding function, allowing the developer to handle the request and generate an appropriate response. For example, the following code defines a simple route in Flask that returns the string \"Hello World!\" when a client accesses the root URL (\"/\"): from flask import Flask app = Flask(__name__) @app.route(\"/\") def home(): return \"Hello World!\" HTTP Verbs and Request Methods HTTP verbs, as mentioned earlier, play a significant role in routing and specifying the intended action on the server-side. Flask allows developers to specify the HTTP methods (GET, POST, PUT, DELETE, etc.) that a particular route supports. This enables finer control over the types of requests that can be handled by a specific route. For instance, the following code defines two routes in Flask: one for handling GET requests to the root URL (\"/\") and another for handling POST requests to the \"/create\" URL: from flask import Flask app = Flask(__name__) @app.route('/', methods=['GET']) def index(): ... @app.route('/create', methods=['POST']) def store(): ... By specifying the allowed HTTP methods, Flask ensures that the appropriate function is invoked based on the method used in the client's request, providing greater flexibility and control over request handling. CRUD-Like Functionality with Flask CRUD (Create, Read, Update, Delete) operations form the foundation of data manipulation in web applications. Flask provides a convenient way to implement CRUD-like functionality by combining routes and HTTP methods. The following code demonstrates how to implement CRUD-like functionality in Flask using decorators: from flask import Flask app = Flask(__name__) # Assume 'index', 'store' etc are functions @app.route('/', methods=['GET'])(index) @app.route('/create', methods=['POST'])(store) @app.route('/<int:user_id>', methods=['GET'])(show) @app.route('/<int:user_id>/edit', methods=['POST'])(update) @app.route('/<int:user_id>', methods=['DELETE'])(destroy) In this code, each decorator associates a specific HTTP method with a URL pattern and the corresponding function. For instance, the @app.route('/create', methods=['POST']) decorator maps the POST method to the \"/create\" URL and invokes the store function when a POST request is made to that URL. Similarly, other decorators handle GET, PUT, and DELETE requests for different URLs, providing a structured and consistent approach to CRUD operations. Summary and Key Concepts Flask, a widely used Python web framework, simplifies the development of web applications by providing a straightforward routing mechanism and support for various HTTP methods. It does not strictly adhere to the Model-View-Controller (MVC) architectural pattern, but it encourages a separation of concerns and clean design practices. Routing in Flask involves mapping URLs to specific functions or actions on the server-side. This enables the application to handle incoming requests and generate appropriate responses based on the requested URL. HTTP verbs play a crucial role in routing, indicating the intended action (e.g., GET, POST, PUT, DELETE). Flask decorators offer a convenient way to enhance function behavior and implement common patterns, such as CRUD-like functionality. They allow developers to add pre- or post-processing logic, inject additional functionality, or perform common tasks in a reusable and maintainable manner. By understanding these concepts and utilizing the tools provided by Flask, developers can create robust and efficient web applications that handle user requests effectively and provide a seamless user experience.","title":"Routes"},{"location":"week1/Week%201_annotated/","text":"Week 1_annotated.pdf (PDF file) Summary Apps Software that runs on mobile devices, typically specific and compact. Originally referred to desktop or mobile applications, but now focuses on small, downloadable programs. Desktop Apps Standalone, often offline Use local data storage Specific frameworks for each OS Mobile Apps Designed for mobile platforms (phones/tablets) Limited screen space, touch interaction Frameworks vary by OS and platform Network-oriented Web Apps Platform-independent Work across devices and OS Components of Applications Storage: Where data is stored Computation: Indexing, searching, etc. Presentation: Displaying content Platforms Desktop, mobile, web-based, embedded Platform features vary (e.g., keyboard/mouse, touchscreen, etc.) Architectures Client-Server: Explicit server and client Distributed (Peer-to-Peer): All peers are considered equal Client-Server Model Explicit differentiation between clients and servers May have local clients on same machine Variants include multiple servers, load balancing, etc. Distributed (Peer-to-Peer) Model All peers are equal Error tolerance and shared information Software Architecture Patterns MVC (Model-View-Controller): Core data, user interface, and business logic MVA, MVP, HMVC, MVVM, etc. Focus of the Course Platform: Web-based Architecture: Client-server Software architecture: Model-View-Controller Building apps that use web-based servers and hypertext markup for display The Web Platform choice for the course Generic, cross-platform, and worth understanding Constraints and costs to consider Historical Background of the Web Telephone networks (circuit switching) Packet switched networks ARPANet, Ethernet, etc. Protocols and inter-network communication IP and TCP Domain names, hypertext, and the World Wide Web Web 2.0 Dynamic pages, HTTP transport mechanism, client-side computation Platform agnostic operating system Performance of Web Apps Latency and response size impact performance Server resources, storage requirements, and client compute resources also affect speed Web Servers Any computer with a network connection Listen for incoming requests and respond accordingly Follow specific protocols HTTP (HyperText Transfer Protocol) Text-based protocol for client requests and server responses Specifies request types (GET, POST, PUT, etc.) Headers convey request information and server capabilities Protocol Defines communication methods between server and client HTTP specifies request types, headers, and response formats Use Cases of HTTP GET: Simple requests POST: Complex form data, file uploads PUT/DELETE: Extensively used in Web 2.0 and APIs Memory and Storage Requirements Server processes can require significant memory for concurrent requests Search engines like Google may need massive data storage for indexing and cross-referencing web pages Lec file Week 1_annotated.pdf (PDF file)","title":"Week 1_annotated.pdf (PDF file)"},{"location":"week1/Week%201_annotated/#week-1_annotatedpdf-pdf-file","text":"Summary Apps Software that runs on mobile devices, typically specific and compact. Originally referred to desktop or mobile applications, but now focuses on small, downloadable programs. Desktop Apps Standalone, often offline Use local data storage Specific frameworks for each OS Mobile Apps Designed for mobile platforms (phones/tablets) Limited screen space, touch interaction Frameworks vary by OS and platform Network-oriented Web Apps Platform-independent Work across devices and OS Components of Applications Storage: Where data is stored Computation: Indexing, searching, etc. Presentation: Displaying content Platforms Desktop, mobile, web-based, embedded Platform features vary (e.g., keyboard/mouse, touchscreen, etc.) Architectures Client-Server: Explicit server and client Distributed (Peer-to-Peer): All peers are considered equal Client-Server Model Explicit differentiation between clients and servers May have local clients on same machine Variants include multiple servers, load balancing, etc. Distributed (Peer-to-Peer) Model All peers are equal Error tolerance and shared information Software Architecture Patterns MVC (Model-View-Controller): Core data, user interface, and business logic MVA, MVP, HMVC, MVVM, etc. Focus of the Course Platform: Web-based Architecture: Client-server Software architecture: Model-View-Controller Building apps that use web-based servers and hypertext markup for display The Web Platform choice for the course Generic, cross-platform, and worth understanding Constraints and costs to consider Historical Background of the Web Telephone networks (circuit switching) Packet switched networks ARPANet, Ethernet, etc. Protocols and inter-network communication IP and TCP Domain names, hypertext, and the World Wide Web Web 2.0 Dynamic pages, HTTP transport mechanism, client-side computation Platform agnostic operating system Performance of Web Apps Latency and response size impact performance Server resources, storage requirements, and client compute resources also affect speed Web Servers Any computer with a network connection Listen for incoming requests and respond accordingly Follow specific protocols HTTP (HyperText Transfer Protocol) Text-based protocol for client requests and server responses Specifies request types (GET, POST, PUT, etc.) Headers convey request information and server capabilities Protocol Defines communication methods between server and client HTTP specifies request types, headers, and response formats Use Cases of HTTP GET: Simple requests POST: Complex form data, file uploads PUT/DELETE: Extensively used in Web 2.0 and APIs Memory and Storage Requirements Server processes can require significant memory for concurrent requests Search engines like Google may need massive data storage for indexing and cross-referencing web pages Lec file","title":"Week 1_annotated.pdf (PDF file)"},{"location":"week1/Week%201_annotated/#week-1_annotatedpdf-pdf-file_1","text":"","title":"Week 1_annotated.pdf (PDF file)"},{"location":"week1/pq_session/","text":"","title":"Pq session"},{"location":"week1/week_activity1/","text":"L ec t u re S u mma ry Week One: Course Overview, Web Architecture, and Network Fundamentals Overview Introduction to the course and its objectives Overview of the different components of web applications Introduction to web architecture and network fundamentals Topics Covered Introduction to the course What is web development? The different components of web applications Web architecture Network fundamentals Activities and Assignments Activity 1.1: Identify the different components of a web application Activity 1.2: Explain the basic concepts of web architecture Assignment 1.1: Write a simple HTML document Resources HTML Tutorial CSS Tutorial Python Tutorial Week Two: HTML and CSS Overview Introduction to HTML and CSS Creating basic web pages using HTML and CSS Styling web pages using CSS Topics Covered Introduction to HTML HTML elements and attributes Creating basic web pages using HTML Introduction to CSS CSS selectors and properties Styling web pages using CSS Activities and Assignments Activity 2.1: Create a simple HTML document Activity 2.2: Style a web page using CSS Assignment 2.1: Create a web page with a header, footer, and sidebar Resources HTML Tutorial CSS Tutorial Bootstrap Tutorial Week Three: JavaScript and jQuery Overview Introduction to JavaScript and jQuery Using JavaScript and jQuery to add interactivity to web pages Creating dynamic web pages using JavaScript and jQuery Topics Covered Introduction to JavaScript JavaScript syntax and data types JavaScript functions and objects Introduction to jQuery jQuery selectors and events Creating dynamic web pages using JavaScript and jQuery Activities and Assignments Activity 3.1: Write a simple JavaScript program Activity 3.2: Use jQuery to add interactivity to a web page Assignment 3.1: Create a web page that uses JavaScript and jQuery to validate a form Resources JavaScript Tutorial jQuery Tutorial Bootstrap Tutorial Week Four: Python and Flask Overview Introduction to Python and Flask Using Python and Flask to create web applications Handling user input and requests Topics Covered Introduction to Python Python syntax and data types Python functions and objects Introduction to Flask Flask routes and views Handling user input and requests Activities and Assignments Activity 4.1: Write a simple Python program Activity 4.2: Create a simple web application using Flask Assignment 4.1: Create a web application that accepts user input and displays it on the screen Resources Python Tutorial Flask Tutorial Bootstrap Tutorial Week Five: Databases and SQLAlchemy Overview Introduction to databases and SQLAlchemy Using SQLAlchemy to interact with databases Creating and managing databases using SQLAlchemy Topics Covered Introduction to databases Database types and structures Introduction to SQLAlchemy SQLAlchemy models and relationships Creating and managing databases using SQLAlchemy Activities and Assignments Activity 5.1: Create a simple database using SQLAlchemy Activity 5.2: Query a database using SQLAlchemy Assignment 5.1: Create a web application that uses SQLAlchemy to interact with a database Resources SQL Tutorial SQLAlchemy Tutorial Bootstrap Tutorial Week Six: Deployment and Security Overview Introduction to deployment and security Deploying web applications to the cloud Securing web applications Topics Covered Introduction to deployment Deployment methods and strategies Introduction to security Web application security threats Securing web applications Activities and Assignments Activity 6.1: Deploy a web application to the cloud Activity 6.2: Secure a web application Assignment 6.1: Create a web application that is deployed to the cloud and secured Resources AWS Tutorial Azure Tutorial Google Cloud Tutorial Week Seven: Project Development Overview Introduction to project development Planning and designing a web application Developing and testing a web application Topics Covered Introduction to project development Project planning and design Web application development Web application testing Activities and Assignments Activity 7.1: Plan and design a web application Activity 7.2: Develop and test a web application Assignment 7.1: Create a web application that meets the requirements of the project brief Resources Project Management Tutorial Agile Development Tutorial Testing Tutorial Week Eight: Project Presentation Overview Presentation of student projects Feedback and discussion Topics Covered Project presentations Feedback and discussion Activities and Assignments Present your project to the class Receive feedback from your classmates and the instructor Discuss the project outcomes and lessons learned Resources Presentation Skills Tutorial Feedback and Discussion Guide Week Nine: Wrap-Up and Assessment Overview Course wrap-up Assessment of student learning Topics Covered Course wrap-up Assessment of student learning Activities and Assignments Complete the course evaluation Submit your final project for assessment Resources Course Evaluation Form Project Assessment Rubric","title":"Week activity1"},{"location":"week2/Week%202_annotated/","text":"Week 2_annotated.pdf (PDF file) Summary Information Representation Computers operate solely on \"bits,\" which are binary digits with values of 0 or 1. Numbers can be represented using bit patterns, such as 6 being represented as 0110 in binary. Negative numbers can be represented using the two's complement notation, such as -6 being represented as 1010. Textual information presents a challenge as it consists of arbitrary characters. ASCII is a 7-bit encoding standard that defines codes for common characters such as letters, numbers, and special symbols. However, ASCII is limited to 128 different entities, making it insufficient for representing text in many languages that use non-Latin characters. Unicode and UTF-8 Unicode is a character encoding standard that aims to provide codes for all living and historical languages. It uses UCS (Universal Character Set) encodings, such as UCS-2 (2 bytes per character) and UCS-4 (4 bytes per character), to accommodate a vast number of characters. UTF-8 is a variable-length encoding format for Unicode that uses 8-bit units. It is widely used on the web because it is efficient for representing common characters while also supporting a wide range of languages. Markup vs Style Markup languages like HTML focus on separating content from its presentation. HTML tags provide semantic meaning to the content, such as indicating a heading ( ) or a paragraph ( ). On the other hand, style sheets like CSS are used to specify the visual presentation of the content, such as font size, color, and layout. HTML (HyperText Markup Language) HTML is the predominant markup language for the web. It allows content to be structured using tags, which can be nested to create complex documents. HTML5 introduced new tags and features, such as , , and , to enhance the semantic representation of content. Document Object Model (DOM) The DOM is a tree-like representation of an HTML document that allows developers to programmatically manipulate the content and structure of the document. Using the DOM, developers can add, remove, or modify elements and their attributes. CSS (Cascading Style Sheets) CSS is used to control the presentation of an HTML document. It allows developers to specify the visual appearance of different elements, such as font, color, size, and layout. CSS can be applied inline (within HTML elements), internally (within the tag), or externally (in a separate style sheet). Responsive Design Responsive design is an approach to web design that ensures the website adapts to different screen sizes and form factors, such as desktops, laptops, tablets, and smartphones. By using CSS media queries, developers can define different styles for different screen sizes, ensuring optimal user experience on all devices. Bootstrap Bootstrap is a popular CSS framework that provides pre-built styles and components for common web elements, such as buttons, forms, and navigation bars. It simplifies the development of responsive web designs by offering a consistent and mobile-first approach. JavaScript JavaScript is a scripting language that is integrated into the web browser. It allows developers to add interactivity and dynamic behavior to web pages, such as handling user input, manipulating the DOM, and creating animations. JavaScript is essential for enhancing the user experience on the web.","title":"Week 2_annotated.pdf (PDF file)"},{"location":"week2/Week%202_annotated/#week-2_annotatedpdf-pdf-file","text":"Summary Information Representation Computers operate solely on \"bits,\" which are binary digits with values of 0 or 1. Numbers can be represented using bit patterns, such as 6 being represented as 0110 in binary. Negative numbers can be represented using the two's complement notation, such as -6 being represented as 1010. Textual information presents a challenge as it consists of arbitrary characters. ASCII is a 7-bit encoding standard that defines codes for common characters such as letters, numbers, and special symbols. However, ASCII is limited to 128 different entities, making it insufficient for representing text in many languages that use non-Latin characters. Unicode and UTF-8 Unicode is a character encoding standard that aims to provide codes for all living and historical languages. It uses UCS (Universal Character Set) encodings, such as UCS-2 (2 bytes per character) and UCS-4 (4 bytes per character), to accommodate a vast number of characters. UTF-8 is a variable-length encoding format for Unicode that uses 8-bit units. It is widely used on the web because it is efficient for representing common characters while also supporting a wide range of languages. Markup vs Style Markup languages like HTML focus on separating content from its presentation. HTML tags provide semantic meaning to the content, such as indicating a heading (","title":"Week 2_annotated.pdf (PDF file)"},{"location":"week2/activity_session_/","text":"Q1 if we are using 8 bit ASCII each character is represented by 8 bits . doc has 8000 charcaters so bits required is 8000* 8 bits = 64000 bits Q2 we have 11 character \\(2^3\\) = 3 bits = 8 combinations , we can represent 8 different characters As we have 11 charater we will need \\(2^4\\) = 4 bits = 16 character 1 character = 4 bits , so n characters storage size = n * 4 bits no of characters = \\(\\\\displaystyle\\\\frac{size\\\\ of\\\\ file}{ bits\\\\ per\\\\ char}\\) = \\(\\\\displaystyle\\\\frac{2*1000*8}{4}\\) = 4000 Styling Precident !important > inline > Internal > External based styling Precident !important > ID > class > Element","title":"Activity session "},{"location":"week2/activity_session_/#q1","text":"if we are using 8 bit ASCII each character is represented by 8 bits . doc has 8000 charcaters so bits required is 8000* 8 bits = 64000 bits","title":"Q1"},{"location":"week2/activity_session_/#q2","text":"we have 11 character \\(2^3\\) = 3 bits = 8 combinations , we can represent 8 different characters As we have 11 charater we will need \\(2^4\\) = 4 bits = 16 character 1 character = 4 bits , so n characters storage size = n * 4 bits no of characters = \\(\\\\displaystyle\\\\frac{size\\\\ of\\\\ file}{ bits\\\\ per\\\\ char}\\) = \\(\\\\displaystyle\\\\frac{2*1000*8}{4}\\) = 4000","title":"Q2"},{"location":"week2/activity_session_/#styling-precident","text":"!important > inline > Internal > External","title":"Styling Precident"},{"location":"week2/activity_session_/#based-styling-precident","text":"!important > ID > class > Element","title":"based styling Precident"},{"location":"week2/aq_pq/","text":"","title":"Aq pq"},{"location":"week3/Accessibility/","text":"Web Accessibility Initiative (WAI) The W3C Web Accessibility Initiative (WAI) outlines several core principles to make web content accessible to people with disabilities. These principles are encapsulated in guidelines such as the Web Content Accessibility Guidelines (WCAG), the Authoring Tool Accessibility Guidelines (ATAG), and the User Agent Accessibility Guidelines (UAAG). Here are some key aspects: Perceivable Information and User Interface : Text Alternatives : Provide text alternatives for non-text content (e.g., images, icons, and multimedia). These text alternatives enable content to be rendered in various forms, such as large print, braille, speech, symbols, or simpler language\u30107\u2020source\u3011. Captions and Audio Descriptions : Offer captions for videos and audio descriptions for visual content, ensuring that users who cannot see or hear the media can still understand the content\u30107\u2020source\u3011. Operable User Interface and Navigation : Keyboard Accessibility : Ensure that all functionality is available from a keyboard. This is crucial for users who cannot use a mouse and rely on keyboard navigation. Enough Time : Provide users enough time to read and use content. This includes mechanisms to extend time limits on activities. Understandable Information and User Interface : Readable Content : Make text readable and understandable. This includes providing clear instructions and using simple language where possible. Predictable Web Pages : Ensure that web pages operate in predictable ways. For example, navigation mechanisms should be consistent throughout the site\u30107\u2020source\u3011. Robust Content and Reliable Interpretation : Compatibility : Content must be robust enough to be interpreted reliably by a wide variety of user agents, including assistive technologies. This involves following web standards and ensuring that content is compatible with current and future technologies. For a comprehensive guide and more details, you can visit the W3C Accessibility Principles page .","title":"Web Accessibility Initiative (WAI)"},{"location":"week3/Accessibility/#web-accessibility-initiative-wai","text":"The W3C Web Accessibility Initiative (WAI) outlines several core principles to make web content accessible to people with disabilities. These principles are encapsulated in guidelines such as the Web Content Accessibility Guidelines (WCAG), the Authoring Tool Accessibility Guidelines (ATAG), and the User Agent Accessibility Guidelines (UAAG). Here are some key aspects: Perceivable Information and User Interface : Text Alternatives : Provide text alternatives for non-text content (e.g., images, icons, and multimedia). These text alternatives enable content to be rendered in various forms, such as large print, braille, speech, symbols, or simpler language\u30107\u2020source\u3011. Captions and Audio Descriptions : Offer captions for videos and audio descriptions for visual content, ensuring that users who cannot see or hear the media can still understand the content\u30107\u2020source\u3011. Operable User Interface and Navigation : Keyboard Accessibility : Ensure that all functionality is available from a keyboard. This is crucial for users who cannot use a mouse and rely on keyboard navigation. Enough Time : Provide users enough time to read and use content. This includes mechanisms to extend time limits on activities. Understandable Information and User Interface : Readable Content : Make text readable and understandable. This includes providing clear instructions and using simple language where possible. Predictable Web Pages : Ensure that web pages operate in predictable ways. For example, navigation mechanisms should be consistent throughout the site\u30107\u2020source\u3011. Robust Content and Reliable Interpretation : Compatibility : Content must be robust enough to be interpreted reliably by a wide variety of user agents, including assistive technologies. This involves following web standards and ensuring that content is compatible with current and future technologies. For a comprehensive guide and more details, you can visit the W3C Accessibility Principles page .","title":"Web Accessibility Initiative (WAI)"},{"location":"week3/Week%203_annotated/","text":"Week 3 Summary MVC Paradigm The Model-View-Controller (MVC) paradigm is an architectural pattern commonly used in software development, including web application development. It separates the application into three distinct components: Model: Responsible for managing the application's data and business logic. Stores and processes data, performing operations like saving, updating, and retrieving information. 2. View: Responsible for presenting the data to the user. Contains the user interface (UI) elements and interacts with the user through visual or auditory cues. 3. Controller: Acts as a mediator between the model and the view. Handles user input, updates the model accordingly, and triggers changes in the view. The separation of these components allows for easier maintenance, adaptability, and code reuse. Origins and Foundations The MVC paradigm originated in the Smalltalk-80 programming language. It is rooted in the principles of object-oriented programming (OOP) and user interface development, where the separation of concerns is crucial for modularity and flexibility. View Design User Interface Considerations: Views encompass the user interface (UI) of a web application, including: Screen displays Audio feedback Haptic feedback (vibrations) Motor controls (e.g., door opening mechanisms) User Interaction: User interaction with the view can vary depending on hardware constraints and target devices. Some common methods include: Keyboard and mouse inputs Touchscreens Spoken voice recognition Custom buttons Types of Views: Views can range in complexity from: Fully static: No dynamic content or interactivity. - Google Partly dynamic: Some elements change based on user input or data. - wiki Mostly dynamic: Majority of the content is dynamically generated and interactive. - AMAZON.IN Output Formats: Views can generate output in various formats, such as: HTML (most commonly used for direct rendering) Dynamic images JSON/XML (machine-readable formats) User Interface Design Principles User interface design plays a significant role in the usability and user experience of a web application. Key principles include: Simplicity: Easy for users to understand and navigate. Efficiency: Users can achieve their goals with minimal effort. Aesthetics: Visually appealing and pleasing to the eye. Accessibility: Accessible to users with disabilities or impairments. Systematic Process User interface design involves a systematic process: Functionality requirements gathering: Determine the essential features and functions. User and task analysis: Understand user preferences and task requirements. Prototyping: Create wireframes and mockups to visualize the design. Testing: Conduct user acceptance, usability, and accessibility evaluations. Guidelines and Heuristics Jakob Nielsen's heuristics for user interface design provide valuable guidelines: Consistency Simple and minimal steps Simple language Minimal and aesthetically pleasing Understanding Jakob Nielsen\u2019s 10 Usability Heuristics for User Interface Design User experience is paramount in designing interfaces, and Jakob Nielsen\u2019s 10 usability heuristics provide foundational principles for creating effective and intuitive user interfaces. These heuristics are broad guidelines that help ensure users have a seamless and enjoyable interaction with digital products. 1. Visibility of System Status Keeping users informed about what\u2019s happening through timely feedback builds trust and reduces uncertainty. 2. Match Between the System and the Real World Using familiar language and conventions helps users understand and navigate interfaces more easily. 3. User Control and Freedom Providing ways to undo actions and exit processes gives users confidence and control over their interactions. 4. Consistency and Standards Maintaining consistency in design and following platform conventions makes learning easier for users. 5. Error Prevention Preventing errors by designing intuitive processes and providing confirmations can save users from frustration. 6. Recognition Rather than Recall Minimizing memory load by making options and information visible aids user recognition and efficiency. 7. Flexibility and Efficiency of Use Designing interfaces that accommodate both novice and experienced users through shortcuts and customization enhances usability. 8. Aesthetic and Minimalist Design Removing unnecessary elements focuses users on important information and tasks, improving usability. 9. Help Users Recognize, Diagnose, and Recover from Errors Clear, plain-language error messages with constructive solutions help users fix problems quickly. 10. Help and Documentation Providing accessible and task-focused help ensures users can find support when needed. These heuristics are crucial for evaluating and improving user interfaces, ensuring they are user-friendly, efficient, and satisfying. For a detailed exploration of each heuristic, visit Nielsen Norman Group's article . Tools and Techniques Various tools and techniques aid in user interface design and implementation: Wireframes: Visual representations of the web page's structure and layout. - HTML generation: Programmatic generation of HTML code using libraries like PyHTML. - Templates: Reusable templates for generating standardized HTML content, such as Jinja2. Accessibility Accessibility ensures that users with disabilities or impairments can access and use a web application. It encompasses various principles: Perceivable: Provide alternatives for non-text content and make content easily discernible. Operable: Enable keyboard navigation, provide ample time for interaction, and avoid seizure-inducing content. Understandable: Use clear language, predictable behavior, and error correction mechanisms. Robust: Maintain compatibility with assistive technologies and future user tools. Aesthetic Considerations While accessibility is paramount, aesthetics also play a crucial role in user engagement and satisfaction. Simplicity, visual appeal, and consistency enhance the user experience. However, aesthetic preferences can vary over time as design trends evolve.","title":"Week 3"},{"location":"week3/Week%203_annotated/#week-3","text":"Summary MVC Paradigm The Model-View-Controller (MVC) paradigm is an architectural pattern commonly used in software development, including web application development. It separates the application into three distinct components: Model: Responsible for managing the application's data and business logic. Stores and processes data, performing operations like saving, updating, and retrieving information. 2. View: Responsible for presenting the data to the user. Contains the user interface (UI) elements and interacts with the user through visual or auditory cues. 3. Controller: Acts as a mediator between the model and the view. Handles user input, updates the model accordingly, and triggers changes in the view. The separation of these components allows for easier maintenance, adaptability, and code reuse. Origins and Foundations The MVC paradigm originated in the Smalltalk-80 programming language. It is rooted in the principles of object-oriented programming (OOP) and user interface development, where the separation of concerns is crucial for modularity and flexibility. View Design User Interface Considerations: Views encompass the user interface (UI) of a web application, including: Screen displays Audio feedback Haptic feedback (vibrations) Motor controls (e.g., door opening mechanisms) User Interaction: User interaction with the view can vary depending on hardware constraints and target devices. Some common methods include: Keyboard and mouse inputs Touchscreens Spoken voice recognition Custom buttons Types of Views: Views can range in complexity from: Fully static: No dynamic content or interactivity. - Google Partly dynamic: Some elements change based on user input or data. - wiki Mostly dynamic: Majority of the content is dynamically generated and interactive. - AMAZON.IN Output Formats: Views can generate output in various formats, such as: HTML (most commonly used for direct rendering) Dynamic images JSON/XML (machine-readable formats) User Interface Design Principles User interface design plays a significant role in the usability and user experience of a web application. Key principles include: Simplicity: Easy for users to understand and navigate. Efficiency: Users can achieve their goals with minimal effort. Aesthetics: Visually appealing and pleasing to the eye. Accessibility: Accessible to users with disabilities or impairments. Systematic Process User interface design involves a systematic process: Functionality requirements gathering: Determine the essential features and functions. User and task analysis: Understand user preferences and task requirements. Prototyping: Create wireframes and mockups to visualize the design. Testing: Conduct user acceptance, usability, and accessibility evaluations. Guidelines and Heuristics Jakob Nielsen's heuristics for user interface design provide valuable guidelines: Consistency Simple and minimal steps Simple language Minimal and aesthetically pleasing","title":"Week 3"},{"location":"week3/Week%203_annotated/#understanding-jakob-nielsens-10-usability-heuristics-for-user-interface-design","text":"User experience is paramount in designing interfaces, and Jakob Nielsen\u2019s 10 usability heuristics provide foundational principles for creating effective and intuitive user interfaces. These heuristics are broad guidelines that help ensure users have a seamless and enjoyable interaction with digital products.","title":"Understanding Jakob Nielsen\u2019s 10 Usability Heuristics for User Interface Design"},{"location":"week3/Week%203_annotated/#1-visibility-of-system-status","text":"Keeping users informed about what\u2019s happening through timely feedback builds trust and reduces uncertainty.","title":"1. Visibility of System Status"},{"location":"week3/Week%203_annotated/#2-match-between-the-system-and-the-real-world","text":"Using familiar language and conventions helps users understand and navigate interfaces more easily.","title":"2. Match Between the System and the Real World"},{"location":"week3/Week%203_annotated/#3-user-control-and-freedom","text":"Providing ways to undo actions and exit processes gives users confidence and control over their interactions.","title":"3. User Control and Freedom"},{"location":"week3/Week%203_annotated/#4-consistency-and-standards","text":"Maintaining consistency in design and following platform conventions makes learning easier for users.","title":"4. Consistency and Standards"},{"location":"week3/Week%203_annotated/#5-error-prevention","text":"Preventing errors by designing intuitive processes and providing confirmations can save users from frustration.","title":"5. Error Prevention"},{"location":"week3/Week%203_annotated/#6-recognition-rather-than-recall","text":"Minimizing memory load by making options and information visible aids user recognition and efficiency.","title":"6. Recognition Rather than Recall"},{"location":"week3/Week%203_annotated/#7-flexibility-and-efficiency-of-use","text":"Designing interfaces that accommodate both novice and experienced users through shortcuts and customization enhances usability.","title":"7. Flexibility and Efficiency of Use"},{"location":"week3/Week%203_annotated/#8-aesthetic-and-minimalist-design","text":"Removing unnecessary elements focuses users on important information and tasks, improving usability.","title":"8. Aesthetic and Minimalist Design"},{"location":"week3/Week%203_annotated/#9-help-users-recognize-diagnose-and-recover-from-errors","text":"Clear, plain-language error messages with constructive solutions help users fix problems quickly.","title":"9. Help Users Recognize, Diagnose, and Recover from Errors"},{"location":"week3/Week%203_annotated/#10-help-and-documentation","text":"Providing accessible and task-focused help ensures users can find support when needed. These heuristics are crucial for evaluating and improving user interfaces, ensuring they are user-friendly, efficient, and satisfying. For a detailed exploration of each heuristic, visit Nielsen Norman Group's article . Tools and Techniques Various tools and techniques aid in user interface design and implementation: Wireframes: Visual representations of the web page's structure and layout. - HTML generation: Programmatic generation of HTML code using libraries like PyHTML. - Templates: Reusable templates for generating standardized HTML content, such as Jinja2. Accessibility Accessibility ensures that users with disabilities or impairments can access and use a web application. It encompasses various principles: Perceivable: Provide alternatives for non-text content and make content easily discernible. Operable: Enable keyboard navigation, provide ample time for interaction, and avoid seizure-inducing content. Understandable: Use clear language, predictable behavior, and error correction mechanisms. Robust: Maintain compatibility with assistive technologies and future user tools. Aesthetic Considerations While accessibility is paramount, aesthetics also play a crucial role in user engagement and satisfaction. Simplicity, visual appeal, and consistency enhance the user experience. However, aesthetic preferences can vary over time as design trends evolve.","title":"10. Help and Documentation"},{"location":"week3/heuristics/","text":"Nielsen Norman Group's Ten Usability Heuristics Usability plays a crucial role in the success of digital products, whether it's a website, mobile app, or software application. To ensure that products are intuitive, efficient, and enjoyable to use, designers and developers can turn to established principles like the Ten Usability Heuristics developed by Jakob Nielsen and Rolf Molich of the Nielsen Norman Group. Visibility of system status : Users should always be informed about what's happening within the system. Clear and timely feedback lets users know if their actions are producing the desired results. Match between system and the real world : The system's language, concepts, and actions should be familiar and consistent with the user's expectations. Using everyday language and metaphors helps users understand and navigate the interface. User control and freedom : Users should have the freedom to navigate the system easily and recover from mistakes. Providing undo options, clear navigation paths, and intuitive controls empowers users to explore confidently. Consistency and standards : Consistency in design elements, terminology, and interactions throughout the system enhances predictability and reduces cognitive load. Following established design patterns and industry standards improves usability. Error prevention : Design should prioritize error prevention over error recovery. By anticipating and addressing potential user errors through clear instructions, constraints, and confirmation dialogs, designers can minimize frustration and improve user satisfaction. Recognition rather than recall : Users shouldn't have to rely on memory to complete tasks. Presenting information, options, and actions in context reduces the cognitive effort required to use the system effectively. Flexibility and efficiency of use : Design should accommodate both novice and experienced users. Providing shortcuts, customizable settings, and efficient workflows enables users to accomplish tasks quickly and with minimal effort. Aesthetic and minimalist design : Keep the interface clean and focused on essential elements. Removing unnecessary clutter and distractions enhances usability and improves the user's ability to focus on the task at hand. Help users recognize, diagnose, and recover from errors : Error messages should be expressed in plain language, indicate the problem clearly, and suggest constructive solutions. Guiding users through the error recovery process reduces frustration and fosters a positive user experience. Help and documentation : While the ideal system is self-explanatory, offering help and documentation when needed is essential. Providing easily accessible resources, such as tutorials, FAQs, and tooltips, supports users in overcoming challenges and learning to use the system effectively. By adhering to these usability heuristics, designers and developers can create digital products that are intuitive, efficient, and enjoyable to use, ultimately enhancing user satisfaction and driving success.","title":"Nielsen Norman Group's Ten Usability Heuristics"},{"location":"week3/heuristics/#nielsen-norman-groups-ten-usability-heuristics","text":"Usability plays a crucial role in the success of digital products, whether it's a website, mobile app, or software application. To ensure that products are intuitive, efficient, and enjoyable to use, designers and developers can turn to established principles like the Ten Usability Heuristics developed by Jakob Nielsen and Rolf Molich of the Nielsen Norman Group. Visibility of system status : Users should always be informed about what's happening within the system. Clear and timely feedback lets users know if their actions are producing the desired results. Match between system and the real world : The system's language, concepts, and actions should be familiar and consistent with the user's expectations. Using everyday language and metaphors helps users understand and navigate the interface. User control and freedom : Users should have the freedom to navigate the system easily and recover from mistakes. Providing undo options, clear navigation paths, and intuitive controls empowers users to explore confidently. Consistency and standards : Consistency in design elements, terminology, and interactions throughout the system enhances predictability and reduces cognitive load. Following established design patterns and industry standards improves usability. Error prevention : Design should prioritize error prevention over error recovery. By anticipating and addressing potential user errors through clear instructions, constraints, and confirmation dialogs, designers can minimize frustration and improve user satisfaction. Recognition rather than recall : Users shouldn't have to rely on memory to complete tasks. Presenting information, options, and actions in context reduces the cognitive effort required to use the system effectively. Flexibility and efficiency of use : Design should accommodate both novice and experienced users. Providing shortcuts, customizable settings, and efficient workflows enables users to accomplish tasks quickly and with minimal effort. Aesthetic and minimalist design : Keep the interface clean and focused on essential elements. Removing unnecessary clutter and distractions enhances usability and improves the user's ability to focus on the task at hand. Help users recognize, diagnose, and recover from errors : Error messages should be expressed in plain language, indicate the problem clearly, and suggest constructive solutions. Guiding users through the error recovery process reduces frustration and fosters a positive user experience. Help and documentation : While the ideal system is self-explanatory, offering help and documentation when needed is essential. Providing easily accessible resources, such as tutorials, FAQs, and tooltips, supports users in overcoming challenges and learning to use the system effectively. By adhering to these usability heuristics, designers and developers can create digital products that are intuitive, efficient, and enjoyable to use, ultimately enhancing user satisfaction and driving success.","title":"Nielsen Norman Group's Ten Usability Heuristics"},{"location":"week4/Mechanisms%20for%20Persistent%20Storage%20and%20Relational%20Databases/","text":"Mechanisms for Persistent Storage and Relational Databases Summary In-Memory Data Structures In-memory data structures are temporary data storage mechanisms that reside within the computer's main memory (RAM). They provide efficient and fast access to data during program execution but are volatile, meaning they are lost when the program terminates or the computer shuts down. In-memory data structures are often used for temporary storage of data that is frequently accessed during program execution. They can take various forms, including: Lists: Ordered collections of elements that can be accessed and modified by their index. Example: names = ['Alice', 'Bob', 'Charlie'] Dictionaries: Collections of key-value pairs, where each key is associated with a specific value. Example: courses = {'Introduction to EE': 0, 'Applied Mech': 1, 'Calculus': 2} Sets: Unordered collections of unique elements. Example: students = {'Alice', 'Bob', 'Charlie'} Limitations of In-Memory Data Structures Data Entry Errors: In-memory data structures are prone to data entry errors due to manual input. Limited Scalability: They are not suitable for storing large amounts of data. Duplicate Data: In-memory data structures can contain duplicate entries. In-Memory Data Structures with Keys Using keys with in-memory data structures can address some of the limitations mentioned above: Reduced Data Entry Errors: Keys can help prevent data entry errors by ensuring that values are associated with unique identifiers. Handling Duplicates: Keys can ensure that duplicate values are not added to the data structure. Objects Objects are a more structured form of data storage in memory. They encapsulate data and behavior within a single unit, making it easier to manage and manipulate complex data. Objects can be defined using classes, which provide a blueprint for creating instances of the object. For example, the following Python class defines a Student object: class Student : idnext = 0 # Class variable to generate unique IDs def __init__ ( self , name ): self . name = name self . id = Student . idnext # Assign unique ID Student . idnext += 1 Objects offer several advantages: Auto-Initialization of Unique IDs: Objects can automatically generate unique identifiers, ensuring that each object has a unique identity. Encapsulation: Objects bundle data and behavior together, making it easier to manage complex data. Persistence In-memory data structures are temporary and are lost when the program terminates. To store data persistently, it needs to be saved to a non-volatile storage medium, such as a disk or database. Various methods can be used for data persistence: Serialization: Python's pickle module can be used to serialize objects into a binary format that can be saved to a file. CSV (Comma-Separated Values) : A simple text-based format for storing tabular data. TSV (Tab-Separated Values) : Similar to CSV but uses tabs as separators. These methods essentially convert data into a format that can be stored on disk. However, they share limitations: Limited Flexibility: Data structures like spreadsheets can be inflexible, making it difficult to represent complex relationships. Limited Functionality: Spreadsheets offer limited capabilities for operations such as stored procedures and atomic operations. Relational Databases (SQL) Relational databases, such as SQL (Structured Query Language), provide a structured and efficient way to store and manage data. They organize data into tables, where each table consists of rows (representing individual records) and columns (representing fields). SQL databases offer several advantages: Tabular Format: Data is stored in a tabular format, making it easy to represent relationships between different tables. Data Integrity: SQL databases enforce data integrity through constraints, ensuring the validity and consistency of data. Queries and Stored Procedures: SQL allows for complex queries to retrieve and manipulate data, and stored procedures provide a way to encapsulate complex operations. Unstructured Databases (NoSQL) NoSQL (Not Only SQL) databases are designed for handling large volumes of unstructured data that does not fit well into the structured format of relational databases. NoSQL databases offer advantages such as: Flexibility: NoSQL databases allow for easy addition and modification of fields, making them suitable for rapidly evolving data structures. Arbitrary Data: They can store data in various formats, including JSON, XML, and binary objects. Scalability: NoSQL databases are designed to handle massive amounts of data, making them suitable for big data applications. However, NoSQL databases may compromise on data integrity and consistency, which may not be suitable for all applications.","title":"Mechanisms for Persistent Storage and Relational Databases"},{"location":"week4/Mechanisms%20for%20Persistent%20Storage%20and%20Relational%20Databases/#mechanisms-for-persistent-storage-and-relational-databases","text":"Summary In-Memory Data Structures In-memory data structures are temporary data storage mechanisms that reside within the computer's main memory (RAM). They provide efficient and fast access to data during program execution but are volatile, meaning they are lost when the program terminates or the computer shuts down. In-memory data structures are often used for temporary storage of data that is frequently accessed during program execution. They can take various forms, including: Lists: Ordered collections of elements that can be accessed and modified by their index. Example: names = ['Alice', 'Bob', 'Charlie'] Dictionaries: Collections of key-value pairs, where each key is associated with a specific value. Example: courses = {'Introduction to EE': 0, 'Applied Mech': 1, 'Calculus': 2} Sets: Unordered collections of unique elements. Example: students = {'Alice', 'Bob', 'Charlie'} Limitations of In-Memory Data Structures Data Entry Errors: In-memory data structures are prone to data entry errors due to manual input. Limited Scalability: They are not suitable for storing large amounts of data. Duplicate Data: In-memory data structures can contain duplicate entries. In-Memory Data Structures with Keys Using keys with in-memory data structures can address some of the limitations mentioned above: Reduced Data Entry Errors: Keys can help prevent data entry errors by ensuring that values are associated with unique identifiers. Handling Duplicates: Keys can ensure that duplicate values are not added to the data structure. Objects Objects are a more structured form of data storage in memory. They encapsulate data and behavior within a single unit, making it easier to manage and manipulate complex data. Objects can be defined using classes, which provide a blueprint for creating instances of the object. For example, the following Python class defines a Student object: class Student : idnext = 0 # Class variable to generate unique IDs def __init__ ( self , name ): self . name = name self . id = Student . idnext # Assign unique ID Student . idnext += 1 Objects offer several advantages: Auto-Initialization of Unique IDs: Objects can automatically generate unique identifiers, ensuring that each object has a unique identity. Encapsulation: Objects bundle data and behavior together, making it easier to manage complex data. Persistence In-memory data structures are temporary and are lost when the program terminates. To store data persistently, it needs to be saved to a non-volatile storage medium, such as a disk or database. Various methods can be used for data persistence: Serialization: Python's pickle module can be used to serialize objects into a binary format that can be saved to a file. CSV (Comma-Separated Values) : A simple text-based format for storing tabular data. TSV (Tab-Separated Values) : Similar to CSV but uses tabs as separators. These methods essentially convert data into a format that can be stored on disk. However, they share limitations: Limited Flexibility: Data structures like spreadsheets can be inflexible, making it difficult to represent complex relationships. Limited Functionality: Spreadsheets offer limited capabilities for operations such as stored procedures and atomic operations. Relational Databases (SQL) Relational databases, such as SQL (Structured Query Language), provide a structured and efficient way to store and manage data. They organize data into tables, where each table consists of rows (representing individual records) and columns (representing fields). SQL databases offer several advantages: Tabular Format: Data is stored in a tabular format, making it easy to represent relationships between different tables. Data Integrity: SQL databases enforce data integrity through constraints, ensuring the validity and consistency of data. Queries and Stored Procedures: SQL allows for complex queries to retrieve and manipulate data, and stored procedures provide a way to encapsulate complex operations. Unstructured Databases (NoSQL) NoSQL (Not Only SQL) databases are designed for handling large volumes of unstructured data that does not fit well into the structured format of relational databases. NoSQL databases offer advantages such as: Flexibility: NoSQL databases allow for easy addition and modification of fields, making them suitable for rapidly evolving data structures. Arbitrary Data: They can store data in various formats, including JSON, XML, and binary objects. Scalability: NoSQL databases are designed to handle massive amounts of data, making them suitable for big data applications. However, NoSQL databases may compromise on data integrity and consistency, which may not be suitable for all applications.","title":"Mechanisms for Persistent Storage and Relational Databases"},{"location":"week4/Presistent%20Storage/","text":"Presistent Storage Summary Persistent Storage Persistent storage is a critical aspect of data management, enabling data to survive server restarts and other interruptions. It is particularly important for data that needs to be stored for extended periods, such as grades or other student records. Requirements for Persistent Storage Reliability: Data must be stored securely and reliably, ensuring its integrity and availability. Durability: Data must persist even in the event of hardware failures or server outages. Scalability: The storage solution must be able to accommodate growing data volumes as the application expands. Cost-effectiveness: The storage solution should be cost-effective and affordable for the organization. Spreadsheets: A Basic Form of Persistent Storage Spreadsheets are a widely used tool for organizing and manipulating tabular data. They allow for data to be stored in rows and columns, with operations defined on individual cells or ranges. Multiple interconnected sheets can exist within a single spreadsheet. However, spreadsheets have limitations in terms of data structuring and the representation of relationships between data items. Relationships and Data Representation For data that involves relationships between different entities, such as students and courses, spreadsheets can become cumbersome and inefficient. Storing each relationship as a separate entry with full details can lead to redundancy and data inconsistency. A more structured approach is required to efficiently represent and manage such relationships. Database Management Systems: A Structured Approach to Data Storage Database management systems (DBMS) provide a structured and efficient way to store and manage data, including support for relationships between data items. They offer features such as: Data Definition Language (DDL): Allows for the creation and modification of database structures, defining tables, columns, and relationships. Data Manipulation Language (DML): Enables the insertion, modification, and retrieval of data from the database. Structured Query Language (SQL): A widely used language for interacting with databases, allowing for complex queries and data manipulation operations. Key Concepts in Database Management Table: A collection of related data organized into rows and columns, where each row represents an individual record and each column represents a specific data attribute. Primary Key: A unique identifier that distinguishes each record in a table. Foreign Key: A column that references a primary key in another table, establishing a relationship between the two tables. Join: An operation that combines rows from two or more tables based on matching values in their foreign and primary keys. Benefits of Using a Database Management System Data Integrity: Enforces data integrity by ensuring data accuracy and consistency through constraints and validation rules. Data Redundancy Reduction: Eliminates duplicate data by storing related data in separate tables and linking them through relationships. Efficient Data Retrieval: Provides fast and efficient data retrieval through optimized indexing and query execution. Scalability: Supports large data volumes and can scale to handle increasing data requirements. Security: Offers features for user authentication, authorization, and data encryption to protect sensitive information. Database Models: Organizing Data Relationships Database models provide a framework for organizing and representing data relationships. Common database models include: Hierarchical Model: Organizes data in a tree-like structure, where each parent record can have multiple child records. Network Model: Similar to the hierarchical model, but allows for more complex relationships where a child record can have multiple parents. Relational Model: The most widely used model, organizes data into tables and uses foreign keys to establish relationships between tables. Object-Oriented Model: Models data as objects, encapsulating both data and behavior, and supports inheritance and polymorphism. Choosing the Right Database Model The choice of database model depends on the specific data structure and the requirements of the application. Relational databases are widely used for structured data with well-defined relationships, while object-oriented databases are more suitable for complex data structures and applications involving inheritance and polymorphism. Advantages and Disadvantages of Database Management Systems Advantages: Ensures data integrity and consistency Reduces data redundancy Facilitates efficient data retrieval Supports scalability and large data volumes Provides security features Disadvantages: Can be complex to design and implement Requires specialized knowledge and expertise May have performance limitations with very large data sets Can incur additional costs for licensing and maintenance Conclusion Persistent storage and database management systems are essential for managing data in modern applications. Spreadsheets provide a basic form of persistent storage but are limited in their ability to handle complex data relationships. Database management systems offer structured and efficient data storage, support for relationships, and features for data integrity and security. The choice of database model and the implementation of a DBMS require careful consideration based on the application's specific data structure and requirements.","title":"Presistent Storage"},{"location":"week4/Presistent%20Storage/#presistent-storage","text":"Summary Persistent Storage Persistent storage is a critical aspect of data management, enabling data to survive server restarts and other interruptions. It is particularly important for data that needs to be stored for extended periods, such as grades or other student records. Requirements for Persistent Storage Reliability: Data must be stored securely and reliably, ensuring its integrity and availability. Durability: Data must persist even in the event of hardware failures or server outages. Scalability: The storage solution must be able to accommodate growing data volumes as the application expands. Cost-effectiveness: The storage solution should be cost-effective and affordable for the organization. Spreadsheets: A Basic Form of Persistent Storage Spreadsheets are a widely used tool for organizing and manipulating tabular data. They allow for data to be stored in rows and columns, with operations defined on individual cells or ranges. Multiple interconnected sheets can exist within a single spreadsheet. However, spreadsheets have limitations in terms of data structuring and the representation of relationships between data items. Relationships and Data Representation For data that involves relationships between different entities, such as students and courses, spreadsheets can become cumbersome and inefficient. Storing each relationship as a separate entry with full details can lead to redundancy and data inconsistency. A more structured approach is required to efficiently represent and manage such relationships. Database Management Systems: A Structured Approach to Data Storage Database management systems (DBMS) provide a structured and efficient way to store and manage data, including support for relationships between data items. They offer features such as: Data Definition Language (DDL): Allows for the creation and modification of database structures, defining tables, columns, and relationships. Data Manipulation Language (DML): Enables the insertion, modification, and retrieval of data from the database. Structured Query Language (SQL): A widely used language for interacting with databases, allowing for complex queries and data manipulation operations. Key Concepts in Database Management Table: A collection of related data organized into rows and columns, where each row represents an individual record and each column represents a specific data attribute. Primary Key: A unique identifier that distinguishes each record in a table. Foreign Key: A column that references a primary key in another table, establishing a relationship between the two tables. Join: An operation that combines rows from two or more tables based on matching values in their foreign and primary keys. Benefits of Using a Database Management System Data Integrity: Enforces data integrity by ensuring data accuracy and consistency through constraints and validation rules. Data Redundancy Reduction: Eliminates duplicate data by storing related data in separate tables and linking them through relationships. Efficient Data Retrieval: Provides fast and efficient data retrieval through optimized indexing and query execution. Scalability: Supports large data volumes and can scale to handle increasing data requirements. Security: Offers features for user authentication, authorization, and data encryption to protect sensitive information. Database Models: Organizing Data Relationships Database models provide a framework for organizing and representing data relationships. Common database models include: Hierarchical Model: Organizes data in a tree-like structure, where each parent record can have multiple child records. Network Model: Similar to the hierarchical model, but allows for more complex relationships where a child record can have multiple parents. Relational Model: The most widely used model, organizes data into tables and uses foreign keys to establish relationships between tables. Object-Oriented Model: Models data as objects, encapsulating both data and behavior, and supports inheritance and polymorphism. Choosing the Right Database Model The choice of database model depends on the specific data structure and the requirements of the application. Relational databases are widely used for structured data with well-defined relationships, while object-oriented databases are more suitable for complex data structures and applications involving inheritance and polymorphism. Advantages and Disadvantages of Database Management Systems Advantages: Ensures data integrity and consistency Reduces data redundancy Facilitates efficient data retrieval Supports scalability and large data volumes Provides security features Disadvantages: Can be complex to design and implement Requires specialized knowledge and expertise May have performance limitations with very large data sets Can incur additional costs for licensing and maintenance Conclusion Persistent storage and database management systems are essential for managing data in modern applications. Spreadsheets provide a basic form of persistent storage but are limited in their ability to handle complex data relationships. Database management systems offer structured and efficient data storage, support for relationships, and features for data integrity and security. The choice of database model and the implementation of a DBMS require careful consideration based on the application's specific data structure and requirements.","title":"Presistent Storage"},{"location":"week4/Relations%20and%20ER%20Diagram/","text":"Relations and ER Diagram Summary Understanding Relationships in Data Modeling Introduction In data modeling, relationships play a crucial role in defining the structure and organization of data. They establish connections between entities, allowing data to be linked and organized in a meaningful way. Understanding the different types of relationships and their representations is essential for designing effective data models. Types of Relationships There are three primary types of relationships in data modeling: One-to-One: A relationship where each entity in one set is associated with at most one entity in the other set. For example, a student can have only one roll number, and a roll number identifies only one student. One-to-Many (Many-to-One): A relationship where each entity in one set is associated with one or more entities in the other set, but each entity in the other set is associated with at most one entity in the first set. For example, a student can stay in only one hostel, while a hostel can have many students. Many-to-Many: A relationship where each entity in one set can be associated with one or more entities in the other set, and each entity in the other set can be associated with one or more entities in the first set. For example, a student can register for multiple courses, and a course can have multiple students. Diagrammatic Representations Relationships in data modeling are often represented using diagrams, such as Entity-Relationship (ER) diagrams and Unified Modeling Language (UML) diagrams. Entity-Relationship Diagrams (ERDs) ERDs are graphical representations that show the entities in a system, their attributes, and the relationships between them. Entities are represented by rectangles, attributes are represented by ovals, and relationships are represented by lines. The cardinality of a relationship (one-to-one, one-to-many, many-to-many) is indicated by symbols on the connecting lines. UML Diagrams UML diagrams use a more standardized notation to represent relationships. Class relationships are represented by lines with different types of arrowheads, where the type of arrowhead indicates the cardinality of the relationship. Additional Relationship Types In addition to the three primary types of relationships, there are several other variations, including: Self-referential relationships: Relationships where an entity can relate to itself. For example, a department can have a manager who is also an employee in the same department. Weak entities: Entities that require a relationship with another entity to exist. For example, a line item on an invoice cannot exist without an invoice. Ternary relationships: Relationships involving three entities. For example, a relationship between students, courses, and grades. Importance of Relationships in Data Modeling Relationships play a vital role in data modeling for several reasons: They define the structure and organization of data, enabling efficient data retrieval and manipulation. They ensure data consistency by maintaining constraints on the connections between entities. They facilitate data normalization, which reduces data redundancy and improves data integrity. They allow for the creation of complex data models that can accurately reflect real-world entities and their interactions. Conclusion Understanding relationships in data modeling is fundamental to designing effective and efficient data models. By comprehending the different types of relationships, their representations, and their importance, data architects and database designers can create data models that meet the requirements of their applications and provide a solid foundation for data-driven decisions.","title":"Relations and ER Diagram"},{"location":"week4/Relations%20and%20ER%20Diagram/#relations-and-er-diagram","text":"Summary Understanding Relationships in Data Modeling Introduction In data modeling, relationships play a crucial role in defining the structure and organization of data. They establish connections between entities, allowing data to be linked and organized in a meaningful way. Understanding the different types of relationships and their representations is essential for designing effective data models. Types of Relationships There are three primary types of relationships in data modeling: One-to-One: A relationship where each entity in one set is associated with at most one entity in the other set. For example, a student can have only one roll number, and a roll number identifies only one student. One-to-Many (Many-to-One): A relationship where each entity in one set is associated with one or more entities in the other set, but each entity in the other set is associated with at most one entity in the first set. For example, a student can stay in only one hostel, while a hostel can have many students. Many-to-Many: A relationship where each entity in one set can be associated with one or more entities in the other set, and each entity in the other set can be associated with one or more entities in the first set. For example, a student can register for multiple courses, and a course can have multiple students. Diagrammatic Representations Relationships in data modeling are often represented using diagrams, such as Entity-Relationship (ER) diagrams and Unified Modeling Language (UML) diagrams. Entity-Relationship Diagrams (ERDs) ERDs are graphical representations that show the entities in a system, their attributes, and the relationships between them. Entities are represented by rectangles, attributes are represented by ovals, and relationships are represented by lines. The cardinality of a relationship (one-to-one, one-to-many, many-to-many) is indicated by symbols on the connecting lines. UML Diagrams UML diagrams use a more standardized notation to represent relationships. Class relationships are represented by lines with different types of arrowheads, where the type of arrowhead indicates the cardinality of the relationship. Additional Relationship Types In addition to the three primary types of relationships, there are several other variations, including: Self-referential relationships: Relationships where an entity can relate to itself. For example, a department can have a manager who is also an employee in the same department. Weak entities: Entities that require a relationship with another entity to exist. For example, a line item on an invoice cannot exist without an invoice. Ternary relationships: Relationships involving three entities. For example, a relationship between students, courses, and grades. Importance of Relationships in Data Modeling Relationships play a vital role in data modeling for several reasons: They define the structure and organization of data, enabling efficient data retrieval and manipulation. They ensure data consistency by maintaining constraints on the connections between entities. They facilitate data normalization, which reduces data redundancy and improves data integrity. They allow for the creation of complex data models that can accurately reflect real-world entities and their interactions. Conclusion Understanding relationships in data modeling is fundamental to designing effective and efficient data models. By comprehending the different types of relationships, their representations, and their importance, data architects and database designers can create data models that meet the requirements of their applications and provide a solid foundation for data-driven decisions.","title":"Relations and ER Diagram"},{"location":"week4/sql/","text":"SQL Summary Relational Databases Relational databases, developed by IBM in the 1970s, are a type of data storage organized in tabular format. They consist of tables, which have columns (fields) and rows (individual entries). Each table represents a specific entity or category of data, such as students, courses, or departments. Key Fields A key field is a unique identifier for each row in a table. The primary key is the most important key field, allowing for fast and efficient access to data, especially in large databases. Foreign keys, on the other hand, are used to establish relationships between different tables, linking related data. Queries Queries are used to retrieve data from a database based on specific criteria. They are written in a structured language called SQL (Structured Query Language), which uses English-like syntax but has a specific format. Queries can be used to find specific records, filter data based on conditions, or perform mathematical operations. Structured Query Language (SQL) SQL is a verbose language that enables users to interact with relational databases. Its syntax includes keywords, operators, and clauses that specify the desired data manipulation or retrieval operations. SQL consists of several specific types of operations, including: Select: Retrieves specific columns or rows from a table From: Specifies the table(s) to retrieve data from Where: Filters the data based on specified conditions Join: Combines data from multiple tables based on matching key fields Inner Join An inner join operation combines rows from two or more tables based on common key fields. It retrieves only the rows that match in both tables, resulting in a smaller dataset that contains only the relevant data. Cartesian Product A Cartesian product is a theoretical operation that combines all rows from two or more tables, resulting in a much larger dataset. However, in practice, it is uncommon to use Cartesian products due to the large number of unnecessary combinations. Query Example: Finding Students Enrolled in Calculus The following SQL query demonstrates how to find all students enrolled in a course named \"Calculus\": SELECT s . name FROM Students s JOIN StudentsCourses sc ON s . IDNumber = sc . studentID JOIN Courses c ON c . ID = sc . courseID WHERE c . name = 'Calculus' ; In this query: The SELECT clause specifies the column to be retrieved (student names). The FROM clause specifies the tables to be joined (Students, StudentsCourses, and Courses). The JOIN clauses specify how the tables are to be joined based on the IDNumber field (studentID and courseID). The WHERE clause filters the results to include only students enrolled in the \"Calculus\" course. Summary Relational databases provide a structured and efficient way to store and manage data in a tabular format. They use keys and relationships to organize and connect data. SQL is a specific language used to interact with relational databases, allowing users to retrieve and manipulate data based on specific criteria. ACID properties ACID properties are a set of principles that ensure reliable processing of database transactions. The acronym ACID stands for Atomicity, Consistency, Isolation, and Durability. Each of these properties contributes to the reliability and robustness of database systems, particularly in multi-user and distributed environments. 1. Atomicity Definition : Ensures that each transaction is treated as a single \"unit,\" which either completes in its entirety or not at all. Key Point : If any part of the transaction fails, the entire transaction fails, and the database state is left unchanged. Example : In a banking system, a transaction transferring money from one account to another will either fully complete (debiting one account and crediting another) or not occur at all. 2. Consistency Definition : Ensures that a transaction brings the database from one valid state to another valid state, maintaining all predefined rules, such as constraints, cascades, and triggers. Key Point : Any data written to the database must be valid according to all defined rules, including integrity constraints. Example : After a transaction, all database invariants, such as foreign key constraints or unique constraints, must be satisfied. 3. Isolation Definition : Ensures that the concurrent execution of transactions leaves the database in the same state that would have been obtained if the transactions were executed sequentially. Key Point : Transactions are isolated from each other; intermediate results of a transaction are not visible to other transactions until the transaction is committed. Example : If two users are concurrently trying to update the same data, the isolation property ensures that one transaction is completed before the other begins, preventing data corruption. 4. Durability Definition : Ensures that once a transaction has been committed, it will remain so, even in the event of a system failure. Key Point : Changes made by committed transactions are permanently recorded in the database and must survive any subsequent failures. Example : After a successful transaction, such as a completed purchase order, the data should persist even if the system crashes immediately afterward. Detailed Examples Atomicity Example Consider a transaction that involves transferring $100 from Alice's account to Bob's account. The transaction involves two steps: Deduct $100 from Alice's account. Add $100 to Bob's account. If the system crashes after step 1 but before step 2, atomicity ensures that Alice's account will not be debited unless Bob's account is credited. The transaction will be rolled back, and Alice's account will remain unchanged. Consistency Example Suppose a database rule states that the balance of any account should never be negative. If a transaction attempts to transfer more money than the available balance in an account, the transaction will fail, maintaining consistency. Isolation Example Two transactions occur simultaneously: Transaction A: Withdraws $50 from Account 1. Transaction B: Transfers $30 from Account 1 to Account 2. Isolation ensures that the transactions do not interfere with each other. One transaction will complete before the other starts, ensuring that Account 1's balance is correctly updated and not affected by the concurrent transaction. Durability Example A transaction records the sale of a product. Once the transaction is committed, the sale information is stored in the database. Even if the system crashes immediately after the transaction commits, the sale information remains recorded, ensuring data is not lost. Importance of ACID Properties Reliability : Ensures the database reliably handles transactions, even in the event of errors, system crashes, or power failures. Data Integrity : Maintains data integrity by ensuring transactions are processed in a reliable and consistent manner. Concurrent Access : Manages concurrent access by multiple users, ensuring isolated and consistent results. Recovery : Facilitates database recovery and error handling, ensuring committed transactions persist while incomplete ones do not affect the database state. By adhering to ACID properties, database systems can ensure that transactions are processed reliably, providing a robust environment for data management and processing.","title":"SQL"},{"location":"week4/sql/#sql","text":"Summary Relational Databases Relational databases, developed by IBM in the 1970s, are a type of data storage organized in tabular format. They consist of tables, which have columns (fields) and rows (individual entries). Each table represents a specific entity or category of data, such as students, courses, or departments. Key Fields A key field is a unique identifier for each row in a table. The primary key is the most important key field, allowing for fast and efficient access to data, especially in large databases. Foreign keys, on the other hand, are used to establish relationships between different tables, linking related data. Queries Queries are used to retrieve data from a database based on specific criteria. They are written in a structured language called SQL (Structured Query Language), which uses English-like syntax but has a specific format. Queries can be used to find specific records, filter data based on conditions, or perform mathematical operations. Structured Query Language (SQL) SQL is a verbose language that enables users to interact with relational databases. Its syntax includes keywords, operators, and clauses that specify the desired data manipulation or retrieval operations. SQL consists of several specific types of operations, including: Select: Retrieves specific columns or rows from a table From: Specifies the table(s) to retrieve data from Where: Filters the data based on specified conditions Join: Combines data from multiple tables based on matching key fields Inner Join An inner join operation combines rows from two or more tables based on common key fields. It retrieves only the rows that match in both tables, resulting in a smaller dataset that contains only the relevant data. Cartesian Product A Cartesian product is a theoretical operation that combines all rows from two or more tables, resulting in a much larger dataset. However, in practice, it is uncommon to use Cartesian products due to the large number of unnecessary combinations. Query Example: Finding Students Enrolled in Calculus The following SQL query demonstrates how to find all students enrolled in a course named \"Calculus\": SELECT s . name FROM Students s JOIN StudentsCourses sc ON s . IDNumber = sc . studentID JOIN Courses c ON c . ID = sc . courseID WHERE c . name = 'Calculus' ; In this query: The SELECT clause specifies the column to be retrieved (student names). The FROM clause specifies the tables to be joined (Students, StudentsCourses, and Courses). The JOIN clauses specify how the tables are to be joined based on the IDNumber field (studentID and courseID). The WHERE clause filters the results to include only students enrolled in the \"Calculus\" course. Summary Relational databases provide a structured and efficient way to store and manage data in a tabular format. They use keys and relationships to organize and connect data. SQL is a specific language used to interact with relational databases, allowing users to retrieve and manipulate data based on specific criteria.","title":"SQL"},{"location":"week4/sql/#acid-properties","text":"ACID properties are a set of principles that ensure reliable processing of database transactions. The acronym ACID stands for Atomicity, Consistency, Isolation, and Durability. Each of these properties contributes to the reliability and robustness of database systems, particularly in multi-user and distributed environments.","title":"ACID properties"},{"location":"week4/sql/#1-atomicity","text":"Definition : Ensures that each transaction is treated as a single \"unit,\" which either completes in its entirety or not at all. Key Point : If any part of the transaction fails, the entire transaction fails, and the database state is left unchanged. Example : In a banking system, a transaction transferring money from one account to another will either fully complete (debiting one account and crediting another) or not occur at all.","title":"1. Atomicity"},{"location":"week4/sql/#2-consistency","text":"Definition : Ensures that a transaction brings the database from one valid state to another valid state, maintaining all predefined rules, such as constraints, cascades, and triggers. Key Point : Any data written to the database must be valid according to all defined rules, including integrity constraints. Example : After a transaction, all database invariants, such as foreign key constraints or unique constraints, must be satisfied.","title":"2. Consistency"},{"location":"week4/sql/#3-isolation","text":"Definition : Ensures that the concurrent execution of transactions leaves the database in the same state that would have been obtained if the transactions were executed sequentially. Key Point : Transactions are isolated from each other; intermediate results of a transaction are not visible to other transactions until the transaction is committed. Example : If two users are concurrently trying to update the same data, the isolation property ensures that one transaction is completed before the other begins, preventing data corruption.","title":"3. Isolation"},{"location":"week4/sql/#4-durability","text":"Definition : Ensures that once a transaction has been committed, it will remain so, even in the event of a system failure. Key Point : Changes made by committed transactions are permanently recorded in the database and must survive any subsequent failures. Example : After a successful transaction, such as a completed purchase order, the data should persist even if the system crashes immediately afterward.","title":"4. Durability"},{"location":"week4/sql/#detailed-examples","text":"","title":"Detailed Examples"},{"location":"week4/sql/#atomicity-example","text":"Consider a transaction that involves transferring $100 from Alice's account to Bob's account. The transaction involves two steps: Deduct $100 from Alice's account. Add $100 to Bob's account. If the system crashes after step 1 but before step 2, atomicity ensures that Alice's account will not be debited unless Bob's account is credited. The transaction will be rolled back, and Alice's account will remain unchanged.","title":"Atomicity Example"},{"location":"week4/sql/#consistency-example","text":"Suppose a database rule states that the balance of any account should never be negative. If a transaction attempts to transfer more money than the available balance in an account, the transaction will fail, maintaining consistency.","title":"Consistency Example"},{"location":"week4/sql/#isolation-example","text":"Two transactions occur simultaneously: Transaction A: Withdraws $50 from Account 1. Transaction B: Transfers $30 from Account 1 to Account 2. Isolation ensures that the transactions do not interfere with each other. One transaction will complete before the other starts, ensuring that Account 1's balance is correctly updated and not affected by the concurrent transaction.","title":"Isolation Example"},{"location":"week4/sql/#durability-example","text":"A transaction records the sale of a product. Once the transaction is committed, the sale information is stored in the database. Even if the system crashes immediately after the transaction commits, the sale information remains recorded, ensuring data is not lost.","title":"Durability Example"},{"location":"week4/sql/#importance-of-acid-properties","text":"Reliability : Ensures the database reliably handles transactions, even in the event of errors, system crashes, or power failures. Data Integrity : Maintains data integrity by ensuring transactions are processed in a reliable and consistent manner. Concurrent Access : Manages concurrent access by multiple users, ensuring isolated and consistent results. Recovery : Facilitates database recovery and error handling, ensuring committed transactions persist while incomplete ones do not affect the database state. By adhering to ACID properties, database systems can ensure that transactions are processed reliably, providing a robust environment for data management and processing.","title":"Importance of ACID Properties"}]}